{
	// Place your algorithm2 ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BellmanFord": {
		"scope": "cpp",
		"prefix": "BellmanFord",
		"body": [
			"template <typename T>",
			"class BellmanFord {",
			"    struct Edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int m_vn;                             // m_vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > m_g;  // m_g[v][]:=(ノードvが始点である有向辺のリスト).",
			"    std::vector<T> m_d;                   // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;               // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"    T m_inf;",
			"",
			"public:",
			"    // constructor.",
			"    BellmanFord() : BellmanFord(0) {}",
			"    explicit BellmanFord(size_t vn, T inf = 1e9) : m_vn(vn), m_g(vn), m_d(vn, inf), m_pre(vn, -1), m_inf(inf) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    T infinity() const { return m_inf; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < m_vn);",
			"        assert(0 <= to and to < m_vn);",
			"        m_g[from].push_back((Edge){to, cost});",
			"    }",
			"    // グラフ全体から負閉路を検出する．O(|V|*|E|).",
			"    bool find_negative_cycle() const {",
			"        std::vector<T> nd(m_vn, 0);",
			"        for(int i = 0; i < m_vn; ++i) {",
			"            bool update = false;",
			"            for(int v = 0; v < m_vn; ++v) {",
			"                for(const Edge &e : m_g[v]) {",
			"                    if(nd[e.to] > nd[v] + e.cost) {",
			"                        nd[e.to] = nd[v] + e.cost;",
			"                        update = true;",
			"                    }",
			"                }",
			"            }",
			"            if(!update) break;",
			"            if(i == m_vn - 1) return true;  // 負閉路あり．",
			"        }",
			"        return false;",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|V|*|E|).",
			"    void bellman_ford(int s) {",
			"        assert(0 <= s and s < m_vn);",
			"        std::fill(m_d.begin(), m_d.end(), m_inf);",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        for(int i = 0; i < 2 * m_vn; ++i) {",
			"            bool update = false;",
			"            for(int v = 0; v < m_vn; ++v) {",
			"                if(m_d[v] == m_inf) continue;",
			"                for(const Edge &e : m_g[v]) {",
			"                    if(m_d[e.to] == -m_inf) continue;",
			"                    if(m_d[e.to] > m_d[v] + e.cost) {",
			"                        if(i < m_vn - 1) {",
			"                            m_d[e.to] = m_d[v] + e.cost;",
			"                            m_pre[e.to] = v;",
			"                        } else {",
			"                            m_d[e.to] = -m_inf;",
			"                        }",
			"                        update = true;",
			"                    }",
			"                }",
			"            }",
			"            if(!update) break;",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> get_path(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        assert(-m_inf < m_d[t] and m_d[t] < m_inf);",
			"        std::vector<int> path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "単一始点最短経路問題"
	},
	"BIT": {
		"scope": "cpp",
		"prefix": "BIT",
		"body": [
			"// Binary Indexed Tree.",
			"template <typename T>",
			"class BIT {",
			"    int sz;               // sz:=(要素数).",
			"    std::vector<T> tree;  // 1-based index.",
			"",
			"    void build() {",
			"        for(int i = 1; i < sz; ++i) {",
			"            int j = i + (i & -i);",
			"            if(j <= sz) tree[j] += tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT() : BIT(0){};",
			"    explicit BIT(size_t sz_) : sz(sz_), tree(sz_ + 1, 0) {}",
			"    explicit BIT(const std::vector<T> &v) : sz(v.size()), tree(v.size() + 1) {",
			"        std::copy(v.begin(), v.end(), tree.begin() + 1);",
			"        build();",
			"    }",
			"",
			"    int size() const { return sz; }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(tree.begin() + 1, tree.end(), a);",
			"        if(a == 0) return;",
			"        build();",
			"    }",
			"    // k番目の要素にaを足す．O(logN).",
			"    void add(int k, T a) {",
			"        assert(1 <= k and k <= sz);",
			"        for(; k <= sz; k += (k & -k)) tree[k] += a;",
			"    }",
			"    // 区間[1,r]の総和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= sz);",
			"        T res = 0;",
			"        for(; r > 0; r -= (r & -r)) res += tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r]の総和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(1 <= l and l <= r and r <= sz);",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"};",
			""
		],
		"description": "Binary Indexed Tree"
	},
	"BIT0": {
		"scope": "cpp",
		"prefix": "BIT0",
		"body": [
			"// Binary Indexed Tree (0-based index).",
			"template <typename T>",
			"class BIT0 {",
			"    int sz;               // sz:=(要素数).",
			"    std::vector<T> tree;  // 0-based index.",
			"",
			"    void build() {",
			"        for(int i = 0; i < sz - 1; ++i) {",
			"            int j = i | (i + 1);",
			"            if(j < sz) tree[j] += tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT0() : BIT0(0){};",
			"    explicit BIT0(size_t sz_) : sz(sz_), tree(sz_, 0) {}",
			"    explicit BIT0(const std::vector<T> &v) : sz(v.size()), tree(v) {",
			"        build();",
			"    }",
			"",
			"    int size() const { return sz; }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(tree.begin(), tree.end(), a);",
			"        if(a == 0) return;",
			"        build();",
			"    }",
			"    // k番目の要素にaを足す．O(logN).",
			"    void add(int k, T a) {",
			"        assert(0 <= k and k < sz);",
			"        for(; k < sz; k |= k + 1) tree[k] += a;",
			"    }",
			"    // 区間[0,r)の和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= sz);",
			"        T res = 0;",
			"        for(r = r - 1; r >= 0; r = (r & (r + 1)) - 1) res += tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r)の和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= sz);",
			"        return sum(r) - sum(l);",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree (0-based index)"
	},
	"BIT2D": {
		"scope": "cpp",
		"prefix": "BIT2D",
		"body": [
			"// Binary Indexed Tree 2D.",
			"template <typename T>",
			"class BIT2D {",
			"    int h;                             // h:=(height).",
			"    int w;                             // w:=(width).",
			"    std::vector<std::vector<T> > dat;  // 1-based index.",
			"",
			"    void build() {",
			"        for(int i = 1; i <= h; ++i)",
			"            for(int j = 1; j <= w; ++j) {",
			"                int ni = i + (i & -i), nj = j + (j & -j);",
			"                bool flag1 = (ni <= h), flag2 = (nj <= w);",
			"                if(flag1) dat[ni][j] += dat[i][j];",
			"                if(flag2) dat[i][nj] += dat[i][j];",
			"                if(flag1 and flag2) dat[ni][nj] -= dat[i][j];",
			"            }",
			"    }",
			"",
			"public:",
			"    // constructor. O(H*W).",
			"    BIT2D() : BIT2D(0, 0) {}",
			"    explicit BIT2D(size_t h_, size_t w_) : h(h_), w(w_), dat(h_ + 1, std::vector<T>(w_ + 1, 0)) {}",
			"    explicit BIT2D(const std::vector<std::vector<T> > &dat_)",
			"        : h(dat_.size()), w(dat_[0].size()), dat(dat_.size() + 1, std::vector<T>(dat_[0].size() + 1)) {",
			"        for(int i = 0; i < h; ++i) std::copy(dat_[i].begin(), dat_[i].end(), dat[i + 1].begin() + 1);",
			"        build();",
			"    }",
			"",
			"    int height() const { return h; }",
			"    int width() const { return w; }",
			"    // 全要素をaで埋める．O(H*W).",
			"    void fill(T a = 0) {",
			"        for(int i = 1; i <= h; ++i) std::fill(dat[i].begin() + 1, dat[i].end(), a);",
			"        if(a == 0) return;",
			"        build();",
			"    }",
			"    // 座標(x,y)にaを加算する．O((logH)*logW).",
			"    void add(int y, int x, T a) {",
			"        assert(1 <= y and y <= h);",
			"        assert(1 <= x and x <= w);",
			"        for(int i = y; i <= h; i += (i & -i))",
			"            for(int j = x; j <= w; j += (j & -j)) dat[i][j] += a;",
			"    }",
			"    // 区間[1,y]かつ[1,x]の総和を求める．O((logH)*logW).",
			"    T sum(int y, int x) const {",
			"        assert(0 <= y and y <= h);",
			"        assert(0 <= x and x <= w);",
			"        T res = 0;",
			"        for(int i = y; i > 0; i -= (i & -i))",
			"            for(int j = x; j > 0; j -= (j & -j)) res += dat[i][j];",
			"        return res;",
			"    }",
			"    // 区間[y,yy]かつ[x,xx]の総和を求める．",
			"    T sum(int y, int x, int yy, int xx) const {",
			"        assert(1 <= y and y <= yy and yy <= h);",
			"        assert(1 <= x and x <= xx and xx <= w);",
			"        return sum(yy, xx) - sum(yy, x - 1) - sum(y - 1, xx) + sum(y - 1, x - 1);",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree 2D"
	},
	"BIT2D0": {
		"scope": "cpp",
		"prefix": "BIT2D0",
		"body": [
			"// Binary Indexed Tree 2D (0-based index).",
			"template <typename T>",
			"class BIT2D0 {",
			"    int h;                             // h:=(height).",
			"    int w;                             // w:=(width).",
			"    std::vector<std::vector<T> > dat;  // 0-based index.",
			"",
			"    void build() {",
			"        for(int i = 0; i < h; ++i)",
			"            for(int j = 0; j < w; ++j) {",
			"                int ni = i | (i + 1), nj = j | (j + 1);",
			"                bool flag1 = (ni < h), flag2 = (nj < w);",
			"                if(flag1) dat[ni][j] += dat[i][j];",
			"                if(flag2) dat[i][nj] += dat[i][j];",
			"                if(flag1 and flag2) dat[ni][nj] -= dat[i][j];",
			"            }",
			"    }",
			"",
			"public:",
			"    // constructor. O(H*W).",
			"    BIT2D0() : BIT2D0(0, 0) {}",
			"    explicit BIT2D0(size_t h_, size_t w_) : h(h_), w(w_), dat(h_, std::vector<T>(w_, 0)) {}",
			"    explicit BIT2D0(const std::vector<std::vector<T> > &dat_) : h(dat_.size()), w(dat_[0].size()), dat(dat_) {",
			"        build();",
			"    }",
			"",
			"    int height() const { return h; }",
			"    int width() const { return w; }",
			"    // 全要素をaで埋める．O(H*W).",
			"    void fill(T a = 0) {",
			"        for(int i = 0; i < h; ++i) std::fill(dat[i].begin(), dat[i].end(), a);",
			"        if(a == 0) return;",
			"        build();",
			"    }",
			"    // 座標(x,y)にaを加算する．O((logH)*logW).",
			"    void add(int y, int x, T a) {",
			"        assert(0 <= y and y < h);",
			"        assert(0 <= x and x < w);",
			"        for(int i = y; i < h; i |= i + 1)",
			"            for(int j = x; j < w; j |= j + 1) dat[i][j] += a;",
			"    }",
			"    // 区間[0,y)かつ[0,x)の総和を求める．O((logH)*logW).",
			"    T sum(int y, int x) const {",
			"        assert(0 <= y and y <= h);",
			"        assert(0 <= x and x <= w);",
			"        T res = 0;",
			"        for(int i = y - 1; i >= 0; i = (i & (i + 1)) - 1)",
			"            for(int j = x - 1; j >= 0; j = (j & (j + 1)) - 1) res += dat[i][j];",
			"        return res;",
			"    }",
			"    // 区間[y,yy)かつ[x,xx)の総和を求める．",
			"    T sum(int y, int x, int yy, int xx) const {",
			"        assert(0 <= y and y <= yy and yy <= h);",
			"        assert(0 <= x and x <= xx and xx <= w);",
			"        return sum(yy, xx) - sum(yy, x) - sum(y, xx) + sum(y, x);",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree 2D (0-based index)"
	},
	"BinaryTrie": {
		"scope": "cpp",
		"prefix": "BinaryTrie",
		"body": [
			"// 非負整数値を扱うTrie木．",
			"template <typename T = unsigned, int B = 32>  // T:データ型, B:ビット長.",
			"class BinaryTrie {",
			"    struct Node {",
			"        int cnt;      // cnt:=(自身を根とする部分木に含まれる要素数).",
			"        Node *ch[2];  // ch[]:=(子のポインタ). 二分木．",
			"        Node() : cnt(0), ch({nullptr, nullptr}) {}",
			"    };",
			"",
			"    Node *root;  // root:=(根のポインタ).",
			"",
			"    void delete_tree(Node *rt) {",
			"        if(rt == nullptr) return;",
			"        for(int i = 0; i < 2; ++i) {",
			"            delete_tree(rt->ch[i]);",
			"            rt->ch[i] = nullptr;",
			"        }",
			"        delete rt;",
			"        rt = nullptr;",
			"    }",
			"    Node *add(Node *p, T x, int shift = B - 1) {",
			"        if(p == nullptr) p = new Node;",
			"        p->cnt++;",
			"        if(shift < 0) return p;",
			"        bool flag = (x >> shift) & (T)1;",
			"        p->ch[flag] = add(p->ch[flag], x, shift - 1);",
			"        return p;",
			"    }",
			"    Node *sub(Node *p, T x, int shift = B - 1) {",
			"        assert(p != nullptr);",
			"        p->cnt--;",
			"        if(p->cnt == 0) {",
			"            delete_tree(p);",
			"            return p = nullptr;",
			"        }",
			"        if(shift < 0) return p;",
			"        bool flag = (x >> shift) & (T)1;",
			"        p->ch[flag] = sub(p->ch[flag], x, shift - 1);",
			"        return p;",
			"    }",
			"    T get_min(Node *p, T bias = 0, int shift = B - 1) const {",
			"        assert(p != nullptr);",
			"        if(shift < 0) return 0;",
			"        bool flag = (bias >> shift) & (T)1;",
			"        if(p->ch[flag] == nullptr) flag = !flag;",
			"        return get_min(p->ch[flag], bias, shift - 1) | ((T)flag << shift);",
			"    }",
			"    T get(Node *p, int k, T bias = 0, int shift = B - 1) const {",
			"        assert(p != nullptr);",
			"        if(shift < 0) return 0;",
			"        bool flag = (bias >> shift) & (T)1;",
			"        int m = (p->ch[flag] == nullptr ? 0 : p->ch[flag]->cnt);",
			"        if(k < m) {",
			"            return get(p->ch[flag], k, bias, shift - 1) | ((T)flag << shift);",
			"        } else {",
			"            flag = !flag;",
			"            return get(p->ch[flag], k - m, bias, shift - 1) | ((T)flag << shift);",
			"        }",
			"    }",
			"    int count_lower(Node *p, T x, int shift = B - 1) const {",
			"        if(p == nullptr or shift < 0) return 0;",
			"        bool flag = (x >> shift) & (T)1;",
			"        return ((flag and p->ch[0] != nullptr) ? p->ch[0]->cnt : 0) + count_lower(p->ch[flag], x, shift - 1);",
			"    }",
			"    void dfs(std::ostream &os, Node *p, int i, bool bits[]) const {",
			"        if(i == B) {",
			"            os << \"[\";",
			"            for(int j = 0; j < B; ++j) os << (bits[j] ? 1 : 0);",
			"            os << \"] (num:\" << p->cnt << \")\" << std::endl;",
			"            return;",
			"        }",
			"        for(int j = 0; j < 2; ++j) {",
			"            if(p->ch[j] != nullptr) {",
			"                bits[i] = j;",
			"                dfs(os, p->ch[j], i + 1, bits);",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor.",
			"    BinaryTrie() : root(nullptr) {",
			"        static_assert(B >= 1);",
			"    }",
			"    ~BinaryTrie() {",
			"        clear();",
			"    }",
			"",
			"    // 集合内でk番目に小さい値を取得．O(B).",
			"    T operator[](int k) const {",
			"        assert(0 <= k and k < size());",
			"        return get(root, k);",
			"    }",
			"",
			"    // 要素数を返す．O(1).",
			"    int size() const { return (root == nullptr ? 0 : root->cnt); }",
			"    // 要素が空かどうか．O(1).",
			"    bool empty() const { return root == nullptr; }",
			"    // 値xの要素数を返す．O(B).",
			"    int count(T x) const {",
			"        if(root == nullptr) return 0;",
			"        Node *p = root;",
			"        for(int i = B - 1; i >= 0; --i) {",
			"            p = p->ch[(x >> i) & (T)1];",
			"            if(p == nullptr) return 0;",
			"        }",
			"        return p->cnt;",
			"    }",
			"    // 値xを集合に1つ追加．O(B).",
			"    void insert(T x) { root = add(root, x); }",
			"    // 値xを集合から1つ削除．O(B).",
			"    void erace(T x) {",
			"        assert(count(x) >= 1);",
			"        root = sub(root, x);",
			"    }",
			"    // 集合内で値xとXORしたときに最小となる値を取得．O(B).",
			"    T min_element(T x = 0) const { return get_min(root, x); }",
			"    // 集合内で値xとXORしたときに最大となる値を取得．O(B).",
			"    T max_element(T x = 0) const { return get_min(root, ~x); }",
			"    // 集合内で値xとXORしたときにk番目に小さい値を取得．O(B).",
			"    T kth_element(int k, T x = 0) const {",
			"        assert(0 <= k and k < size());",
			"        return get(root, k, x);",
			"    }",
			"    // 集合内で値x以上の最小の要素の番号を取得．O(B).",
			"    int lower_bound(T x) const { return count_lower(root, x); }",
			"    // 集合内で値xより大きい最小の要素の番号を取得．O(B).",
			"    int upper_bound(T x) const { return count_lower(root, x + 1); }",
			"    void clear() {",
			"        delete_tree(root);",
			"        root = nullptr;",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const BinaryTrie &ob) {",
			"        if(ob.empty()) return os;",
			"        bool bits[B] = {};",
			"        ob.dfs(os, ob.root, 0, bits);",
			"    }",
			"};"
		],
		"description": "非負整数値を扱うTrie木"
	},
	"Combination": {
		"scope": "cpp",
		"prefix": "Combination",
		"body": [
			"// 二項係数（mod付き）．",
			"template <int mod>",
			"class Combination {",
			"    int sz;                       // sz:=(要素数). 制約は sz<=mod．",
			"    std::vector<long long> fact;  // fact[n]:=(nの階乗).",
			"    std::vector<long long> inv;   // inv[n]:=(nの逆元).",
			"    std::vector<long long> finv;  // finv[n]:=(nの階乗の逆元).",
			"",
			"    void build() {",
			"        fact[0] = fact[1] = 1;",
			"        inv[1] = 1;",
			"        finv[0] = finv[1] = 1;",
			"        for(int n = 2; n < sz; ++n) {",
			"            fact[n] = fact[n - 1] * n % mod;",
			"            inv[n] = mod - inv[mod % n] * (mod / n) % mod;",
			"            finv[n] = finv[n - 1] * inv[n] % mod;",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    Combination() : Combination(51e4) {}",
			"    explicit Combination(size_t sz_) : sz(sz_), fact(sz_), inv(sz_), finv(sz_) {",
			"        static_assert(mod >= 1);",
			"        assert(2 <= sz and sz <= mod);",
			"        build();",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // 階乗．",
			"    long long factorial(int n) const {",
			"        assert(0 <= n and n < sz);",
			"        return fact[n];",
			"    }",
			"    // 逆元．",
			"    long long inverse(int n) const {",
			"        assert(1 <= n and n < sz);",
			"        return inv[n];",
			"    }",
			"    // 階乗の逆元．",
			"    long long inverse_fact(int n) const {",
			"        assert(0 <= n and n < sz);",
			"        return finv[n];",
			"    }",
			"    // 順列．",
			"    long long nPk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n < sz);",
			"        return fact[n] * finv[n - k] % mod;",
			"    }",
			"    // 組み合わせ．",
			"    long long nCk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n < sz);",
			"        return fact[n] * finv[n - k] % mod * finv[k] % mod;",
			"    }",
			"    // 重複組み合わせ．",
			"    long long nHk(int n, int k) const { return nCk(k + n - 1, n - 1); }",
			"};",
			"",
			"using Combination998244353  = Combination<998'244'353>;",
			"using Combination1000000007 = Combination<1'000'000'007>;"
		],
		"description": "二項係数（mod付き）"
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "Dijkstra",
		"body": [
			"template <typename T>",
			"class Dijkstra {",
			"    template <typename Type>",
			"    using r_priority_queue = std::priority_queue<Type, std::vector<Type>, std::greater<Type> >;",
			"    struct Edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int m_vn;                             // m_vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > m_g;  // m_g[v][]:=(ノードvが始点である有向辺のリスト).",
			"    std::vector<T> m_d;                   // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;               // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"    T m_inf;",
			"",
			"public:",
			"    // constructor.",
			"    Dijkstra() : Dijkstra(0) {}",
			"    explicit Dijkstra(size_t vn, T inf = 1e9) : m_vn(vn), m_g(vn), m_d(vn, inf), m_pre(vn, -1), m_inf(inf) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    T infinity() const { return m_inf; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < m_vn);",
			"        assert(0 <= to and to < m_vn);",
			"        m_g[from].push_back((Edge){to, cost});",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|E|*log|V|).",
			"    void dijkstra(int s) {",
			"        assert(0 <= s and s < m_vn);",
			"        std::fill(m_d.begin(), m_d.end(), m_inf);",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        r_priority_queue<std::pair<T, int> > pque;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(m_d[v] < dist) continue;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(m_d[e.to] > m_d[v] + e.cost) {",
			"                    m_d[e.to] = m_d[v] + e.cost;",
			"                    m_pre[e.to] = v;",
			"                    pque.emplace(m_d[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> get_path(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        std::vector<int> path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "単一始点最短経路問題"
	},
	"Dinic": {
		"scope": "cpp",
		"prefix": "Dinic",
		"body": [
			"template <typename T>",
			"class Dinic {",
			"    struct Edge {",
			"        int to;       // to:=(行き先ノード).",
			"        T cap, icap;  // cap:=(容量), icap:=(元の容量).",
			"        int rev;      // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), icap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    int vn;                             // vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > g;  // g[v][]:=(ノードvがもつ辺のリスト).",
			"    std::vector<int> level;             // level[v]:=(ノードsからvまでの距離).",
			"    std::vector<int> iter;              // iter[v]:=(ノードvがもつ辺リストの次に調べるべきイテレータ).",
			"    T inf;",
			"",
			"    void init() {",
			"        for(std::vector<Edge> &es : g)",
			"            for(Edge &e : es) e.cap = e.icap;",
			"    }",
			"    // ノードsから各ノードへの最短距離を計算する．",
			"    void bfs(int s) {",
			"        std::fill(level.begin(), level.end(), -1);",
			"        level[s] = 0;",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            for(const Edge &e : g[v]) {",
			"                if(e.cap > 0 and level[e.to] == -1) {",
			"                    level[e.to] = level[v] + 1;",
			"                    que.push(e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // 増加パスを探す．",
			"    T dfs(int v, int t, T f) {",
			"        if(v == t) return f;",
			"        const int n = g[v].size();",
			"        for(int &i = iter[v]; i < n; ++i) {",
			"            Edge &e = g[v][i];",
			"            if(e.cap > 0 and level[v] < level[e.to]) {",
			"                T res = dfs(e.to, t, std::min(f, e.cap));",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    // constructor.",
			"    Dinic() : Dinic(0) {}",
			"    explicit Dinic(size_t vn_, T inf_ = 1e9) : vn(vn_), g(vn_), level(vn_), iter(vn_), inf(inf_) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return vn; }",
			"    T infinity() const { return inf; }",
			"    // 容量capの有向辺を追加する．",
			"    void add_directed_egde(int from, int to, T cap) {",
			"        assert(0 <= from and from < vn);",
			"        assert(0 <= to and to < vn);",
			"        assert(from != to);",
			"        g[from].emplace_back(to, cap, g[to].size());",
			"        g[to].emplace_back(from, 0, g[from].size() - 1);",
			"    }",
			"    // 容量capの無向辺を追加する．",
			"    void add_undirected_edge(int u, int v, T cap) {",
			"        assert(0 <= u and u < vn);",
			"        assert(0 <= v and v < vn);",
			"        assert(u != v);",
			"        g[u].emplace_back(v, cap, g[v].size());",
			"        g[v].emplace_back(u, cap, g[u].size() - 1);",
			"    }",
			"    // ノードsからtへの最大流を求める．O(|E|*(|V|^2)).",
			"    T max_flow(int s, int t) {",
			"        assert(0 <= s and s < vn);",
			"        assert(0 <= t and t < vn);",
			"        init();",
			"        T flow = 0;",
			"        while(flow < inf) {",
			"            bfs(s);",
			"            if(level[t] == -1) return flow;",
			"            std::fill(iter.begin(), iter.end(), 0);",
			"            T tmp;",
			"            while((tmp = dfs(s, t, inf)) > 0) flow += tmp;",
			"        }",
			"        return inf;",
			"    }",
			"};"
		],
		"description": "最大流問題"
	},
	"DynamicModint": {
		"scope": "cpp",
		"prefix": "DynamicModint",
		"body": [
			"template <int id>",
			"class DynamicModint {",
			"    static int mod;",
			"    long long val;",
			"",
			"public:",
			"    // constructor.",
			"    DynamicModint() : DynamicModint(0) {}",
			"    DynamicModint(long long val_) : val(val_) {",
			"        assert(mod >= 1);",
			"        val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"    DynamicModint operator+() const { return DynamicModint(*this); }",
			"    DynamicModint operator-() const { return DynamicModint(0) - (*this); }",
			"    DynamicModint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    DynamicModint operator++(int) {",
			"        DynamicModint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    DynamicModint operator--(int) {",
			"        DynamicModint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    DynamicModint &operator+=(const DynamicModint &a) {",
			"        val += a.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator-=(const DynamicModint &a) {",
			"        val -= a.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator*=(const DynamicModint &a) {",
			"        val = val * a.val % mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator/=(const DynamicModint &a) { return (*this) *= a.inv(); }",
			"",
			"    friend DynamicModint operator+(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) += y; }",
			"    friend DynamicModint operator-(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) -= y; }",
			"    friend DynamicModint operator*(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) *= y; }",
			"    friend DynamicModint operator/(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) /= y; }",
			"    friend bool operator==(const DynamicModint &x, const DynamicModint &y) { return x.val == y.val; }",
			"    friend bool operator!=(const DynamicModint &x, const DynamicModint &y) { return x.val != y.val; }",
			"    friend std::istream &operator>>(std::istream &is, DynamicModint &x) {",
			"        is >> x.val;",
			"        x.val %= mod;",
			"        if(x.val < 0) x.val += mod;",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const DynamicModint &x) { return os << x.val; }",
			"",
			"    static constexpr int get_id() { return id; }",
			"    static void set_modulus(int mod_) {",
			"        assert(mod_ >= 1);",
			"        mod = mod_;",
			"    }",
			"    static int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    DynamicModint inv() const {",
			"        long long a = val, b = mod, u = 1, v = 0;",
			"        while(b) {",
			"            long long t = a / b;",
			"            a -= t * b, u -= t * v;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return DynamicModint(u);",
			"    }",
			"",
			"    friend DynamicModint mod_pow(const DynamicModint &x, long long k) {",
			"        if(k < 0) return mod_pow(x.inv(), -k);",
			"        DynamicModint res = 1, tmp = x;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= tmp;",
			"            tmp = tmp * tmp;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
			"template <int id>",
			"int DynamicModint<id>::mod = 1'000'000'007;"
		],
		"description": ""
	},
	"FordFulkerson": {
		"scope": "cpp",
		"prefix": "FordFulkerson",
		"body": [
			"template <typename T>",
			"class FordFulkerson {",
			"    struct Edge {",
			"        int to;       // to:=(行き先ノード).",
			"        T cap, icap;  // cap:=(容量), icap:=(元の容量).",
			"        int rev;      // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), icap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    int vn;                             // vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > g;  // g[v][]:=(ノードvがもつ辺のリスト).",
			"    bool *seen;                         // seen[v]:=(DFSでノードvを調べたか).",
			"    T inf;",
			"",
			"    void init() {",
			"        for(std::vector<Edge> &es : g)",
			"            for(Edge &e : es) e.cap = e.icap;",
			"    }",
			"    // 増加パスを探す．",
			"    T dfs(int v, int t, T f) {",
			"        if(v == t) return f;",
			"        seen[v] = true;",
			"        for(Edge &e : g[v]) {",
			"            if(!seen[e.to] and e.cap > 0) {",
			"                T res = dfs(e.to, t, std::min(f, e.cap));",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    // constructor.",
			"    FordFulkerson() : FordFulkerson(0) {}",
			"    explicit FordFulkerson(size_t vn_, T inf_ = 1e9) : vn(vn_), g(vn_), inf(inf_) {",
			"        seen = new bool[vn]{};",
			"    }",
			"",
			"    // ノード数を返す．",
			"    int size() const { return vn; }",
			"    T infinity() const { return inf; }",
			"    // 容量capの有向辺を追加する．",
			"    void add_directed_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < vn);",
			"        assert(0 <= to and to < vn);",
			"        assert(from != to);",
			"        g[from].emplace_back(to, cap, g[to].size());",
			"        g[to].emplace_back(from, 0, g[from].size() - 1);",
			"    }",
			"    // 容量capの無向辺を追加する．",
			"    void add_undirected_edge(int u, int v, T cap) {",
			"        assert(0 <= u and u < vn);",
			"        assert(0 <= v and v < vn);",
			"        assert(u != v);",
			"        g[u].emplace_back(v, cap, g[v].size());",
			"        g[v].emplace_back(u, cap, g[u].size() - 1);",
			"    }",
			"    // ノードsからtへの最大流を調べる．O(F*|E|).",
			"    T max_flow(int s, int t) {",
			"        assert(0 <= s and s < vn);",
			"        assert(0 <= t and t < vn);",
			"        init();",
			"        T flow = 0;",
			"        while(flow < inf) {",
			"            std::fill(seen, seen + vn, false);",
			"            T tmp = dfs(s, t, inf);",
			"            if(tmp == 0) return flow;",
			"            flow += tmp;",
			"        }",
			"        return inf;",
			"    }",
			"};"
		],
		"description": "最大流問題"
	},
	"Heap": {
		"scope": "cpp",
		"prefix": "Heap",
		"body": [
			"template <typename T>",
			"class Heap {",
			"    using F = std::function<bool(T &, T &)>;",
			"",
			"    F comp;               // bool comp(T&,T&):=(比較演算関数).",
			"    int sz;               // sz:=(要素数).",
			"    int depth;            // depth:=(二分木の高さ).",
			"    std::vector<T> tree;  // tree[]:=(二分木). 1-based index.",
			"",
			"    int shift_up(int k) {",
			"        assert(1 <= k and k <= sz);",
			"        if(k == 1) return 1;",
			"        int par = k / 2;",
			"        if(comp(tree[par], tree[k])) return k;",
			"        std::swap(tree[par], tree[k]);",
			"        return par;",
			"    }",
			"    void all_shift_up(int k) {",
			"        while(1) {",
			"            int next = shift_up(k);",
			"            if(next == k) return;",
			"            k = next;",
			"        }",
			"    }",
			"    int shift_down(int k) {",
			"        assert(1 <= k and k <= sz);",
			"        if(k > sz / 2) return k;",
			"        int l = 2 * k, r = 2 * k + 1;",
			"        if(r > sz or comp(tree[l], tree[r])) {",
			"            if(comp(tree[k], tree[l])) return k;",
			"            std::swap(tree[k], tree[l]);",
			"            return l;",
			"        } else {",
			"            if(comp(tree[k], tree[r])) return k;",
			"            std::swap(tree[k], tree[r]);",
			"            return r;",
			"        }",
			"    }",
			"    void all_shift_down(int k) {",
			"        while(1) {",
			"            int next = shift_down(k);",
			"            if(next == k) return;",
			"            k = next;",
			"        }",
			"    }",
			"    void heap_sort() {",
			"        int k = sz / 2;",
			"        for(int i = k; i >= 1; --i) all_shift_down(i);",
			"    }",
			"",
			"public:",
			"    // constructor. O(N*logN).",
			"    Heap() : Heap([](const T &a, const T &b) -> bool { return true; }, std::vector<T>(0)) {}",
			"    explicit Heap(const F &comp_) : Heap(comp_, std::vector<T>(0)) {}",
			"    explicit Heap(const std::vector<T> &v) : Heap([](const T &a, const T &b) -> bool { return true; }, v) {}",
			"    explicit Heap(const F &comp_, const std::vector<T> &v) : comp(comp_), sz(v.size()), depth(-1), tree(v.size() + 1) {",
			"        if(sz > 0) {",
			"            std::copy(v.begin(), v.end(), tree.begin() + 1);",
			"            depth = 0;",
			"            while((1 << (depth + 1)) - 1 < sz) depth++;",
			"            heap_sort();",
			"        }",
			"    }",
			"    ~Heap() {",
			"        std::vector<T>().swap(tree);",
			"    }",
			"",
			"    int size() const { return sz; }",
			"    bool empty() const { return sz == 0; }",
			"    // 先頭の要素を返す．O(1).",
			"    T top() const {",
			"        assert(sz > 0);",
			"        return tree[1];",
			"    }",
			"    // 挿入．O(logN).",
			"    void insert(const T &a) {",
			"        tree.push_back(a), sz++;",
			"        if(depth == -1) depth = 0;",
			"        while((1 << (depth + 1)) - 1 < sz) depth++;",
			"        all_shift_up(sz);",
			"    }",
			"    // 先頭削除．O(logN).",
			"    T pop() {",
			"        assert(sz > 0);",
			"        T res = tree[1];",
			"        tree[1] = tree[sz];",
			"        tree.pop_back(), sz--;",
			"        if(sz == 0) {",
			"            depth = -1;",
			"            return res;",
			"        }",
			"        while(sz < (1 << depth)) depth--;",
			"        all_shift_down(1);",
			"        return res;",
			"    }",
			"    // ヒープソート．O(N).",
			"    void heap_sort(const F &comp_) {",
			"        comp = comp_;",
			"        heap_sort();",
			"    }",
			"};"
		],
		"description": ""
	},
	"Kitamasa": {
		"scope": "cpp",
		"prefix": "Kitamasa",
		"body": [
			"// きたまさ法．",
			"// k項間漸化式 a[n]=d[0]*a[n-k]+d[1]*a[n-k+1]+....+d[k-1]*a[n-1] を求める．O((K^2)*logN).",
			"template <typename T = long long>",
			"class Kitamasa {",
			"    int k;             // k:=(漸化式の階数).",
			"    std::vector<T> a;  // a[]:=(初項ベクトル).",
			"    std::vector<T> d;  // d[]:=(係数ベクトル).",
			"",
			"    // f(n)->f(n+1). O(K).",
			"    std::vector<T> add(const std::vector<T> &x) const {",
			"        std::vector<T> y(k);",
			"        y[0] = d[0] * x[k - 1];",
			"        for(int i = 1; i < k; ++i) y[i] = x[i - 1] + d[i] * x[k - 1];",
			"        return y;",
			"    }",
			"    // f(n)->f(2*n). O(K^2).",
			"    std::vector<T> mul(const std::vector<T> &x) const {",
			"        std::vector<T> y(k, 0);",
			"        std::vector<T> t = x;",
			"        for(int i = 0; i < k; ++i) {",
			"            for(int j = 0; j < k; ++j) y[j] += x[i] * t[j];",
			"            if(i < k - 1) t = add(t);",
			"        }",
			"        return y;",
			"    }",
			"    // f(n)を返す．O((K^2)*logN).",
			"    std::vector<T> f(long long n) const {",
			"        if(n == 0) {",
			"            std::vector<T> x(k, 0);",
			"            x[0] = 1;",
			"            return x;  // f(0).",
			"        }",
			"        std::vector<T> &&x = mul(f(n / 2));",
			"        if(n & 1LL) x = add(x);",
			"        return x;",
			"    }",
			"",
			"public:",
			"    // constructor.",
			"    Kitamasa() : Kitamasa(std::vector<T>({0, 1}), std::vector<T>({1, 1})) {}  // フィボナッチ数列．",
			"    explicit Kitamasa(const std::vector<T> &a_, const std::vector<T> &d_) : k(a_.size()), a(a_), d(d_) {",
			"        assert(k >= 1 and a.size() == d.size());",
			"    }",
			"",
			"    T operator[](long long n) const { return calc(n); }",
			"",
			"    // a[n]を返す．O((K^2)*logN).",
			"    T calc(long long n) const {",
			"        assert(n >= 0);",
			"        std::vector<T> &&x = f(n);",
			"        T res = 0;",
			"        for(int i = 0; i < k; ++i) res += x[i] * a[i];",
			"        return res;",
			"    }",
			"};"
		],
		"description": "きたまさ法"
	},
	"LazySegTree": {
		"scope": "cpp",
		"prefix": "LazySegTree",
		"body": [
			"// 遅延評価セグメント木．",
			"template <class Monoid, class Action>",
			"class LazySegTree {",
			"    using FM = std::function<Monoid(Monoid, Monoid)>;",
			"    using FA = std::function<void(Monoid &, Action)>;",
			"    using FC = std::function<void(Action &, Action)>;",
			"",
			"    FM op;                     // Monoid op(Monoid,Monoid):=(二項演算関数). M•M.",
			"    FA action;                 // void action(Monoid&,Action):=(作用素によるモノイド元への作用). M×A.",
			"    FC composition;            // void composition(Action&,Action):=(作用素の合成). A•A.",
			"    Monoid e;                  // e:=(単位元).",
			"    Action id;                 // id:=(作用素の単位元).",
			"    int sz;                    // sz:=(要素数).",
			"    int n;                     // n:=(二分木の葉数).",
			"    int depth;                 // depth:=(二分木の深さ).",
			"    std::vector<Monoid> tree;  // tree(2n)[]:=(完全二分木). 1-based index.",
			"    std::vector<Action> lazy;  // lazy(n)[k]:=(tree[k]の子 (tree[2k], tree[2k+1]) に対する遅延評価).",
			"",
			"    void build() {",
			"        n = 1, depth = 0;",
			"        while(!(n >= sz)) n <<= 1, depth++;",
			"        tree.assign(2 * n, e);",
			"        lazy.assign(n, id);",
			"    }",
			"    void apply0(int k, const Action &d) {",
			"        assert(1 <= k and k < 2 * n);",
			"        action(tree[k], d);",
			"        if(k < n) composition(lazy[k], d);",
			"    }",
			"    void push(int k) {",
			"        assert(1 <= k and k < n);",
			"        apply0(2 * k, lazy[k]);",
			"        apply0(2 * k + 1, lazy[k]);",
			"        lazy[k] = id;",
			"    }",
			"    void update(int k) {",
			"        assert(1 <= k and k < n);",
			"        tree[k] = op(tree[2 * k], tree[2 * k + 1]);",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    LazySegTree() {}",
			"    explicit LazySegTree(const FM &op_, const FA &action_, const FC &composition_,",
			"                         const Monoid &e_, const Action &id_, size_t sz_)",
			"        : op(op_), action(action_), composition(composition_), e(e_), id(id_), sz(sz_) {",
			"        build();",
			"    }",
			"    explicit LazySegTree(const FM &op_, const FA &action_, const FC &composition_,",
			"                         const Monoid &e_, const Action &id_, const std::vector<Monoid> &v)",
			"        : op(op_), action(action_), composition(composition_), e(e_), id(id_), sz(v.size()) {",
			"        build();",
			"        std::copy(v.begin(), v.end(), tree.begin() + n);",
			"        for(int i = n - 1; i >= 1; --i) update(i);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return sz; }",
			"    // モノイドの単位元を返す．",
			"    Monoid identity() const { return e; }",
			"    // 作用素の単位元を返す．",
			"    Action action_identity() const { return id; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const Monoid &a) {",
			"        assert(0 <= k and k < sz);",
			"        k += n;",
			"        for(int i = depth; i >= 1; --i) push(k >> i);",
			"        tree[k] = a;",
			"        for(int i = 1; i <= depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,r)の要素をv[]に置き換える．O(N).",
			"    void set(int l, int r, const std::vector<Monoid> &v) {",
			"        assert(0 <= l and l <= r and r <= sz);",
			"        assert(v.size() == r - l);",
			"        if(l == r) return;",
			"        l += n, r += n;",
			"        for(int i = depth; i >= 1; --i) {",
			"            if(((l >> i) << i) != l) push(l >> i);",
			"            if(((r >> i) << i) != r) push((r - 1) >> i);",
			"        }",
			"        std::copy(v.begin(), v.end(), tree.begin() + l);",
			"        for(int i = 1; i <= depth; ++i) {",
			"            int l2 = (l >> i), r2 = ((r - 1) >> i);",
			"            for(int j = l2; j <= r2; ++j) update(j);",
			"        }",
			"    }",
			"    // k番目の要素を作用素dを用いて更新する．O(logN).",
			"    void apply(int k, const Action &d) {",
			"        assert(0 <= k and k < sz);",
			"        k += n;",
			"        for(int i = depth; i >= 1; --i) push(k >> i);",
			"        action(tree[k], d);",
			"        for(int i = 1; i <= depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,r)を作用素dを用いて更新する．O(logN).",
			"    void apply(int l, int r, const Action &d) {",
			"        assert(0 <= l and l <= r and r <= sz);",
			"        if(l == r) return;",
			"        l += n, r += n;",
			"        for(int i = depth; i >= 1; --i) {",
			"            if(((l >> i) << i) != l) push(l >> i);",
			"            if(((r >> i) << i) != r) push((r - 1) >> i);",
			"        }",
			"        for(int l2 = l, r2 = r; l2 < r2; l2 >>= 1, r2 >>= 1) {",
			"            if(l2 & 1) apply0(l2++, d);",
			"            if(r2 & 1) apply0(--r2, d);",
			"        }",
			"        for(int i = 1; i <= depth; ++i) {",
			"            if(((l >> i) << i) != l) update(l >> i);",
			"            if(((r >> i) << i) != r) update((r - 1) >> i);",
			"        }",
			"    }",
			"    // 一点取得．O(logN).",
			"    Monoid prod(int k) {",
			"        assert(0 <= k and k < sz);",
			"        k += n;",
			"        for(int i = depth; i >= 1; --i) push(k >> i);",
			"        return tree[k];",
			"    }",
			"    // 区間[l,r)の総積 (v[l]•v[l+1]•....•v[r-1]) を求める．O(logN).",
			"    Monoid prod(int l, int r) {",
			"        assert(0 <= l and l <= r and r <= sz);",
			"        if(l == r) return e;",
			"        l += n, r += n;",
			"        for(int i = depth; i >= 1; --i) {",
			"            if(((l >> i) << i) != l) push(l >> i);",
			"            if(((r >> i) << i) != r) push((r - 1) >> i);",
			"        }",
			"        Monoid lv = e, rv = e;",
			"        for(; l < r; l >>= 1, r >>= 1) {",
			"            if(l & 1) lv = op(lv, tree[l++]);",
			"            if(r & 1) rv = op(tree[--r], rv);",
			"        }",
			"        return op(lv, rv);",
			"    }",
			"    // 区間全体の総積を返す．O(1).",
			"    Monoid prod_all() const { return tree[1]; }",
			"    // jud(prod(l,-))=trueとなる区間の最右位値を二分探索する．",
			"    // ただし要素列には単調性があり，またjud(e)=trueであること．O(logN).",
			"    int most_right(const std::function<bool(Monoid)> &jud, int l) const {",
			"        assert(jud(e));",
			"        assert(0 <= l and l <= sz);",
			"        if(l == sz) return sz;",
			"        l += n;",
			"        for(int i = depth; i >= 1; --i) push(l >> i);",
			"        Monoid val = e;",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            Monoid &&tmp = op(val, tree[l]);",
			"            if(!jud(tmp)) {",
			"                while(l < n) {",
			"                    push(l);",
			"                    l *= 2;",
			"                    Monoid &&tmp2 = op(val, tree[l]);",
			"                    if(jud(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==xのとき，xは2の階乗数．",
			"        return sz;",
			"    }",
			"    // jud(prod(-,r))=trueとなる区間の最左位値を二分探索する．",
			"    // ただし要素列には単調性があり，またjud(e)=trueであること．O(logN).",
			"    int most_left(const std::function<bool(Monoid)> &jud, int r) const {",
			"        assert(jud(e));",
			"        assert(0 <= r and r <= sz);",
			"        if(r == 0) return 0;",
			"        r += n;",
			"        for(int i = depth; i >= 1; --i) push((r - 1) >> i);",
			"        Monoid val = e;",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            Monoid &&tmp = op(tree[r], val);",
			"            if(!jud(tmp)) {",
			"                while(r < n) {",
			"                    push(r);",
			"                    r = 2 * r + 1;",
			"                    Monoid &&tmp2 = op(tree[r], val);",
			"                    if(jud(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==xのとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() {",
			"        std::fill(tree.begin(), tree.end(), e);",
			"        std::fill(lazy.begin(), lazy.end(), id);",
			"    }",
			"};"
		],
		"description": "遅延評価セグメント木"
	},
	"LCA": {
		"scope": "cpp",
		"prefix": "LCA",
		"body": [
			"// 最近共通祖先 (LCA:Lowest Common Ancestor)．",
			"class LCA {",
			"    int m_vn;                              // m_vn:=(ノード数).",
			"    int m_h;                               // m_h:=ceiling(log2(m_vn)).",
			"    int m_rt;                              // m_rt:=(根番号).",
			"    std::vector<std::vector<int> > m_g;    // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::vector<int> > m_par;  // m_par[v][k]:=(ノードvから2^k回辿って到達する親ノード番号). 親がいない場合は-1．",
			"    std::vector<int> m_depth;              // m_depth[v]:=(ノードvの深さ). 根に連結していない場合は-1．",
			"    bool m_update;",
			"",
			"    void dfs(int u, int p, int d) {",
			"        assert(m_depth[u] == -1);",
			"        m_par[u][0] = p, m_depth[u] = d;",
			"        for(auto v : m_g[u]) {",
			"            if(v != p) dfs(v, u, d + 1);",
			"        }",
			"    }",
			"    // 祖先木を構築する．O(|V|*log|V|).",
			"    void build() {",
			"        for(auto &a : m_par) std::fill(a.begin(), a.end(), -1);",
			"        std::fill(m_depth.begin(), m_depth.end(), -1);",
			"        dfs(m_rt, -1, 0);",
			"        for(int k = 1; k < m_h; ++k)",
			"            for(int v = 0; v < m_vn; ++v) {",
			"                if(m_par[v][k - 1] != -1) m_par[v][k] = m_par[m_par[v][k - 1]][k - 1];",
			"            }",
			"        m_update = false;",
			"    }",
			"",
			"public:",
			"    // constructor. O(log|V|).",
			"    LCA() : LCA(0) {}",
			"    explicit LCA(size_t vn, int rt = 0) : m_vn(vn), m_h(1), m_rt(rt), m_g(vn), m_depth(vn, -1), m_update(true) {",
			"        while((1 << m_h) < m_vn) m_h++;",
			"        m_par.assign(m_vn, std::vector<int>(m_h, -1));",
			"    }",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    // 根番号を返す．",
			"    int root() const { return m_rt; }",
			"    // 根番号を変更する．",
			"    void set_root(int rt) {",
			"        assert(0 <= rt and rt < m_vn);",
			"        m_rt = rt;",
			"        m_update = true;",
			"    }",
			"    // ノードuとvに辺を繋げる．",
			"    void add_edge(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        m_g[u].push_back(v);",
			"        m_g[v].push_back(u);",
			"        m_update = true;",
			"    }",
			"    // ノードuとvの最も近い共通の先祖を求める．O(log|V|).",
			"    int lca(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        if(m_update) build();",
			"        if(m_depth[u] == -1 or m_depth[v] == -1) return -1;  // 非連結．",
			"        if(m_depth[u] > m_depth[v]) std::swap(u, v);",
			"        for(int k = 0; k < m_h; ++k) {",
			"            if((m_depth[v] - m_depth[u]) & (1 << k)) v = m_par[v][k];  // 同じ深さに合わせる．",
			"        }",
			"        if(u == v) return u;",
			"        for(int k = m_h - 1; k >= 0; --k) {",
			"            if(m_par[u][k] != m_par[v][k]) u = m_par[u][k], v = m_par[v][k];  // 異なったら根に近づける．",
			"        }",
			"        return m_par[u][0];",
			"    }",
			"    // ノードvの深さを返す．",
			"    int get_depth(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        if(m_update) build();",
			"        return m_depth[v];",
			"    }",
			"    // ノードuとvの距離を求める．O(log|V|).",
			"    int distance(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        if(m_update) build();",
			"        if(m_depth[u] == -1 or m_depth[v] == -1) return -1;  // 非連結．",
			"        return m_depth[u] + m_depth[v] - 2 * m_depth[lca(u, v)];",
			"    }",
			"};"
		],
		"description": "最近共通祖先 (LCA:Lowest Common Ancestor)"
	},
	"LinearSieve": {
		"scope": "cpp",
		"prefix": "LinearSieve",
		"body": [
			"// 線形篩．",
			"class LinearSieve {",
			"    int m_mx;                   // m_mx:=(篩にかける最大の自然数).",
			"    std::vector<int> m_lpf;     // m_lpf[n]:=(自然数nの最小の素因数). Least prime factor. m_lpf[n]==nのとき，nは素数．",
			"    std::vector<int> m_primes;  // m_primes[]:=(素数のリスト).",
			"",
			"public:",
			"    // constructor. mx以下の自然数を篩にかける．O(N).",
			"    LinearSieve() : LinearSieve(51e4) {}",
			"    explicit LinearSieve(int mx) : m_mx(mx), m_lpf(mx + 1, -1) {",
			"        assert(m_mx >= 0);",
			"        for(int p = 2; p <= m_mx; ++p) {",
			"            if(m_lpf[p] == -1) {",
			"                m_lpf[p] = p;",
			"                m_primes.push_back(p);",
			"            }",
			"            int sz = m_primes.size();",
			"            for(int i = 0; i < sz and m_primes[i] <= m_lpf[p] and p * m_primes[i] <= m_mx; ++i) m_lpf[p * m_primes[i]] = m_primes[i];",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小の素因数を返す．O(1).",
			"    int get_lpf(int n) const {",
			"        assert(2 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const auto &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[i] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    const std::vector<int> &get_primes() const { return m_primes; }",
			"};"
		],
		"description": "線形篩"
	},
	"LowLink": {
		"scope": "cpp",
		"prefix": "LowLink",
		"body": [
			"class LowLink {",
			"    int vn;                                 // vn:=(頂点数).",
			"    std::vector<std::vector<int> > g;       // g[v][]:=(頂点vの隣接リスト).",
			"    std::vector<int> ord;                   // ord[v]:=(DFS木における頂点vの行きかけ順序).",
			"    std::vector<int> low;                   // low[v]:=(DFS木にて，葉方向に0回以上，後退辺を高々1回用いて到達できる頂点wにおけるord[w]の最小値).",
			"    std::vector<int> aps;                   // aps[]:=(関節点のリスト). Articulations points.",
			"    std::vector<std::pair<int, int> > brs;  // brs[]:=(橋のリスト). Bridges.",
			"",
			"    void init() {",
			"        std::fill(ord.begin(), ord.end(), -1);",
			"        aps.clear();",
			"        brs.clear();",
			"    }",
			"    void dfs(int u, int par, int &cnt) {",
			"        ord[u] = low[u] = cnt++;",
			"        int degree = 0;      // DFS木での頂点uにおける葉方向への出次数．",
			"        bool is_ap = false;  // 頂点uが関節点か否か．",
			"        for(auto v : g[u]) {",
			"            if(ord[v] == -1) {  // 頂点vが未訪問のとき．",
			"                degree++;",
			"                dfs(v, u, cnt);",
			"                low[u] = std::min(low[u], low[v]);",
			"                if(ord[u] < low[v]) {  // 辺u-vが橋のとき．",
			"                    if(u < v)",
			"                        brs.emplace_back(u, v);",
			"                    else",
			"                        brs.emplace_back(v, u);",
			"                }",
			"                if(par != -1 and ord[u] <= low[v]) is_ap = true;  // 根以外で関節点のとき．",
			"            } else if(v != par) {                                 // 辺u-vが後退辺のとき．",
			"                low[u] = std::min(low[u], ord[v]);",
			"            }",
			"        }",
			"        if(par == -1 and degree > 1) is_ap = true;  // 根が関節点のとき．",
			"        if(is_ap) aps.push_back(u);",
			"    }",
			"",
			"public:",
			"    // constructor.",
			"    LowLink() : LowLink(0) {}",
			"    explicit LowLink(size_t vn_) : vn(vn_), g(vn_), ord(vn_), low(vn_) {}",
			"",
			"    // 頂点数を返す．",
			"    int size() const { return vn; }",
			"    // 無向辺を張る．",
			"    void add_edge(int u, int v) {",
			"        assert(0 <= u and u < vn);",
			"        assert(0 <= v and v < vn);",
			"        g[u].push_back(v);",
			"        g[v].push_back(u);",
			"    }",
			"    // 無向グラフの橋と関節点を求める．O(|V|+|E|).",
			"    void calc() {",
			"        init();",
			"        int cnt = 0;",
			"        for(int v = 0; v < vn; ++v) {",
			"            if(ord[v] == -1) dfs(v, -1, cnt);",
			"        }",
			"        std::sort(aps.begin(), aps.end());",
			"        std::sort(brs.begin(), brs.end());",
			"    }",
			"    // 関節点のリストを参照する．",
			"    const std::vector<int> &get_aps() const { return aps; }",
			"    // 橋のリストを参照する．",
			"    const std::vector<std::pair<int, int> > &get_brs() const { return brs; }",
			"};"
		],
		"description": "関節点，橋"
	},
	"Manacher": {
		"scope": "cpp",
		"prefix": "Manacher",
		"body": [
			"// 最長回文 (Longest Palindromic Substring)．",
			"template <class Class>",
			"class Manacher {",
			"    int n;  // n:=(配列サイズ).",
			"    // radius[2*k]:=(k文字目を中心とする奇数長の最長回文の半径),",
			"    // radius[2*k-1]:=(k-1文字目とk文字目の間を中心とする偶数長の最長回文の半径).",
			"    std::vector<int> radius;",
			"",
			"    void manacher(const Class &t) {",
			"        int i = 0, j = 0;",
			"        while(i < 2 * n - 1) {",
			"            while(0 <= i - j and i + j < 2 * n - 1 and t[i - j] == t[i + j]) j++;",
			"            radius[i] = j;",
			"            int k = 1;",
			"            while(i - k >= 0 and radius[i - k] + k < j) {",
			"                radius[i + k] = radius[i - k];",
			"                k++;",
			"            }",
			"            i += k, j -= k;",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. 引数はSTLのシーケンスコンテナ．O(|S|).",
			"    Manacher() : Manacher(Class()) {}",
			"    explicit Manacher(const Class &s) : n(s.size()), radius(2 * s.size()) {",
			"        Class t(2 * n, 0);",
			"        for(int i = 0; i < n; ++i) t[2 * i] = s[i];",
			"        manacher(t);",
			"    }",
			"",
			"    // k文字目を中心とする奇数長の最長回文の半径を返す．",
			"    int get_odd(int k) const {",
			"        assert(0 <= k and k < n);",
			"        return (radius[2 * k] + 1) / 2;",
			"    }",
			"    // k-1文字目とk文字目の間を中心とする偶数長の最長回文の半径を返す．",
			"    int get_even(int k) const {",
			"        assert(1 <= k and k < n);",
			"        return radius[2 * k - 1] / 2;",
			"    }",
			"    // 部分列s[l:r]が回文か判定する．",
			"    bool is_palindrome(int l, int r) const {",
			"        assert(0 <= l and l < r and r <= n);",
			"        int mid = (l + r) / 2;",
			"        if((r - l) & 1)",
			"            return get_odd(mid) == (r - l + 1) / 2;",
			"        else",
			"            return get_even(mid) == (r - l) / 2;",
			"    }",
			"};"
		],
		"description": "最長回文 (Longest Palindromic Substring)"
	},
	"Modint": {
		"scope": "cpp",
		"prefix": "Modint",
		"body": [
			"template <int mod>",
			"class Modint {",
			"    long long val;",
			"",
			"public:",
			"    // constructor.",
			"    Modint() : Modint(0) {}",
			"    Modint(long long val_) : val(val_) {",
			"        static_assert(mod >= 1);",
			"        if(!(0 <= val and val < mod)) {",
			"            val %= mod;",
			"            if(val < 0) val += mod;",
			"        }",
			"    }",
			"",
			"    Modint operator+() const { return Modint(*this); }",
			"    Modint operator-() const { return Modint(0) - (*this); }",
			"    Modint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    Modint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    Modint operator++(int) {",
			"        Modint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    Modint operator--(int) {",
			"        Modint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    Modint &operator+=(const Modint &a) {",
			"        val += a.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    Modint &operator-=(const Modint &a) {",
			"        val -= a.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    Modint &operator*=(const Modint &a) {",
			"        val = val * a.val % mod;",
			"        return *this;",
			"    }",
			"    Modint &operator/=(const Modint &a) { return (*this) *= a.inv(); }",
			"",
			"    friend Modint operator+(const Modint &x, const Modint &y) { return Modint(x) += y; }",
			"    friend Modint operator-(const Modint &x, const Modint &y) { return Modint(x) -= y; }",
			"    friend Modint operator*(const Modint &x, const Modint &y) { return Modint(x) *= y; }",
			"    friend Modint operator/(const Modint &x, const Modint &y) { return Modint(x) /= y; }",
			"    friend bool operator==(const Modint &x, const Modint &y) { return x.val == y.val; }",
			"    friend bool operator!=(const Modint &x, const Modint &y) { return x.val != y.val; }",
			"    friend std::istream &operator>>(std::istream &is, Modint &x) {",
			"        is >> x.val;",
			"        x.val %= mod;",
			"        if(x.val < 0) x.val += mod;",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Modint &x) { return os << x.val; }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    Modint inv() const {",
			"        long long a = val, b = mod, u = 1, v = 0;",
			"        while(b) {",
			"            long long t = a / b;",
			"            a -= t * b, u -= t * v;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return Modint(u);",
			"    }",
			"",
			"    friend Modint mod_pow(const Modint &x, long long k) {",
			"        if(k < 0) return mod_pow(x.inv(), -k);",
			"        Modint res = 1, tmp = x;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= tmp;",
			"            tmp = tmp * tmp;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
			"using mint998244353  = Modint<998'244'353>;",
			"using mint1000000007 = Modint<1'000'000'007>;"
		],
		"description": ""
	},
	"Montmort": {
		"scope": "cpp",
		"prefix": "Montmort",
		"body": [
			"// 完全順列（mod付き）．",
			"template <int mod>",
			"class Montmort {",
			"    int m_sz;",
			"    std::vector<long long> m_a;  // m_a[k]:=(k番目のモンモール数).",
			"",
			"public:",
			"    Montmort() : Montmort(51e4) {}",
			"    explicit Montmort(size_t sz) : m_sz(sz), m_a(sz) {",
			"        static_assert(mod >= 1);",
			"        assert(m_sz >= 2);",
			"        m_a[0] = 1, m_a[1] = 0;",
			"        for(int i = 2; i < m_sz; ++i) m_a[i] = (i - 1) * ((m_a[i - 2] + m_a[i - 1]) % mod) % mod;  // 隣接三項間の漸化式．",
			"        // for(int i = 2; i < m_sz; ++i) m_a[i] = (i * m_a[i - 1] % mod + (i & 1 ? -1 : 1) + mod) % mod;  // 隣接二項間の漸化式．",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // k個の要素を並び替えたときに完全順列となる通り数．",
			"    long long montmort(int k) const {",
			"        assert(1 <= k and k < m_sz);",
			"        return m_a[k];",
			"    }",
			"    // 無限個の要素を並び替えたときに完全順列となる確率．",
			"    static constexpr double convergence_probability() { return 1.0 / std::exp(1.0); }",
			"};"
		],
		"description": "完全順列（mod付き）"
	},
	"PotentializedUnionFind": {
		"scope": "cpp",
		"prefix": "PotentializedUnionFind",
		"body": [
			"// 重み付きUnion-Find Tree．",
			"template <typename T>",
			"class PotentializedUnionFind {",
			"    int m_vn;                // m_vn:=(ノード数).",
			"    int m_gn;                // m_gn:=(グループ数).",
			"    std::vector<int> m_par;  // m_par[v]:=(ノードvの親番号). 0未満の場合，vが親で，値の絶対値がグループサイズを表す．",
			"    std::vector<T> m_p;      // m_p[v]:=(ノードvのポテンシャル).",
			"",
			"public:",
			"    // constructor.",
			"    PotentializedUnionFind() : PotentializedUnionFind(0) {}",
			"    explicit PotentializedUnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1), m_p(vn, 0) {}",
			"",
			"    // ノード数を返す．",
			"    int get_vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int get_gn() const { return m_gn; };",
			"    // ノードvの親番号を返す．",
			"    int root(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        if(m_par[v] < 0) return v;",
			"        auto res = root(m_par[v]);  // recrusion.",
			"        m_p[v] += m_p[m_par[v]];",
			"        return m_par[v] = res;",
			"    }",
			"    // ノードvが属するグループのサイズを返す．",
			"    int size(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        return -m_par[root(v)];",
			"    }",
			"    // ノードvのポテンシャルを返す．",
			"    T potential(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        root(v);",
			"        return m_p[v];",
			"    }",
			"    // ノードuとvが同じグループか判定する．",
			"    bool same(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        return root(u) == root(v);",
			"    }",
			"    // ノードuに対するvの相対ポテンシャルを返す．",
			"    T difference(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        return potential(v) - potential(u);",
			"    }",
			"    // difference(u,v)=dとなるようにノードuとvの親ノードを結合する．",
			"    bool unite(int u, int v, T d) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        d = d + potential(u) - potential(v);",
			"        u = root(u), v = root(v);",
			"        if(u == v) return false;  // Do nothing.",
			"        if(size(u) < size(v)) {   // Merge technique.",
			"            swap(u, v);",
			"            d = -d;",
			"        }",
			"        m_par[u] += m_par[v];",
			"        m_par[v] = u, m_p[v] = d;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = m_vn;",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"        std::fill(m_p.begin(), m_p.end(), 0);",
			"    }",
			"};"
		],
		"description": "重み付きUnion-Find Tree"
	},
	"Prim": {
		"scope": "cpp",
		"prefix": "Prim",
		"body": [
			"template <typename T>",
			"class Prim {",
			"    struct Edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int m_vn;                                // m_vn:=(ノード数).",
			"    int m_n;                                 // m_n:=(葉の数).",
			"    std::vector<std::vector<Edge> > m_g;     // m_g[v][]:=(ノードvがもつ辺のリスト).",
			"    std::vector<std::pair<T, int> > m_heap;  // m_heap[]:=(完全二分木). 1-based index.",
			"    T m_inf;",
			"",
			"    void shiht_up(int i) {",
			"        assert(m_n <= i and i < 2 * m_n);",
			"        while(i >>= 1) m_heap[i] = std::min(m_heap[2 * i], m_heap[2 * i + 1]);",
			"    }",
			"    void push(T cost, int k) {",
			"        assert(0 <= k and k < m_vn);",
			"        if(cost >= m_heap[k + m_n].first) return;",
			"        m_heap[k + m_n] = std::pair<T, int>(cost, k);",
			"        shiht_up(k + m_n);",
			"    }",
			"    void pop() {",
			"        auto [_, k] = m_heap[1];",
			"        if(k == -1) return;",
			"        m_heap[k + m_n] = std::pair<T, int>(m_inf, -1);",
			"        shiht_up(k + m_n);",
			"    }",
			"    std::pair<T, int> top() const { return m_heap[1]; }",
			"",
			"public:",
			"    // constructor.",
			"    Prim() : Prim(0) {}",
			"    explicit Prim(size_t vn, T inf = 1e9) : m_vn(vn), m_g(vn), m_inf(inf) {",
			"        m_n = 1;",
			"        while(m_n < m_vn) m_n <<= 1;",
			"        m_heap.assign(2 * m_n, std::pair<T, int>(m_inf, -1));",
			"    }",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    // 重み付き無向辺を張る．",
			"    void add_edge(int u, int v, T cost) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        m_g[u].push_back((Edge){v, cost});",
			"        m_g[v].push_back((Edge){u, cost});",
			"    }",
			"    // ノードvを含む最小全域木のコストを求める．O(|E|*log|V|).",
			"    T prim(int v = 0) {",
			"        assert(0 <= v and v < m_vn);",
			"        T res = 0;",
			"        bool seen[m_vn] = {};",
			"        push(0, v);",
			"        while(1) {",
			"            auto [cost, u] = top();",
			"            if(u == -1) break;",
			"            pop();",
			"            if(seen[u]) continue;",
			"            seen[u] = true;",
			"            res += cost;",
			"            for(const Edge &e : m_g[u]) {",
			"                if(!seen[e.to]) push(e.cost, e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "最小全域木問題"
	},
	"PrimalDual": {
		"scope": "cpp",
		"prefix": "PrimalDual",
		"body": [
			"template <typename Flow, typename Cost>  // Flow:容量の型, Cost:コストの型.",
			"class PrimalDual {",
			"    template <class Type>",
			"    using r_priority_queue = std::priority_queue<Type, std::vector<Type>, std::greater<Type> >;",
			"    struct Edge {",
			"        int to;          // to:=(行き先ノード).",
			"        Flow cap, icap;  // cap:=(容量), icap:=(元の容量).",
			"        Cost cost;       // cost:=(単位コスト).",
			"        int rev;         // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, Flow cap_, Cost cost_, int rev_)",
			"            : to(to_), cap(cap_), icap(cap_), cost(cost_), rev(rev_) {}",
			"    };",
			"",
			"    int m_vn;                             // m_vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > m_g;  // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<Cost> m_level;            // m_level[v]:=(ノートvまでの最短距離).",
			"    std::vector<Cost> m_p;                // m_p[v]:=(ノードvのポテンシャル).",
			"    std::vector<int> m_prevv;             // m_prevv[v]:=(ノードvの直前に訪れるノード). 逆方向経路．",
			"    std::vector<int> m_preve;             // m_preve[v]:=(ノードvの直前に通る辺). 逆方向経路．",
			"    Cost m_inf;",
			"",
			"    void init() {",
			"        for(std::vector<Edge> &es : m_g)",
			"            for(Edge &e : es) e.cap = e.icap;",
			"        std::fill(m_p.begin(), m_p.end(), 0);",
			"    }",
			"    void dijkstra(int s) {",
			"        std::fill(m_level.begin(), m_level.end(), m_inf);",
			"        m_level[s] = 0;",
			"        r_priority_queue<std::pair<Cost, int> > pque;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [cost, v] = pque.top();",
			"            pque.pop();",
			"            if(m_level[v] < cost) continue;",
			"            const int sz = m_g[v].size();",
			"            for(int i = 0; i < sz; ++i) {",
			"                const Edge &e = m_g[v][i];",
			"                if(e.cap > 0 and m_level[e.to] > m_level[v] + e.cost - m_p[v] + m_p[e.to]) {",
			"                    m_level[e.to] = m_level[v] + e.cost - m_p[v] + m_p[e.to];",
			"                    m_prevv[e.to] = v;",
			"                    m_preve[e.to] = i;",
			"                    pque.emplace(m_level[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor.",
			"    PrimalDual() : PrimalDual(0) {}",
			"    explicit PrimalDual(size_t vn, Cost inf = 1e9)",
			"        : m_vn(vn), m_g(vn), m_level(vn), m_p(vn), m_prevv(vn), m_preve(vn), m_inf(inf) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    // 容量cap，コストcostの有向辺を追加する．",
			"    void add_egde(int from, int to, Flow cap, Cost cost) {",
			"        assert(0 <= from and from < m_vn);",
			"        assert(0 <= to and to < m_vn);",
			"        m_g[from].emplace_back(to, cap, cost, m_g[to].size());",
			"        m_g[to].emplace_back(from, 0, -cost, m_g[from].size() - 1);",
			"    }",
			"    // ソースからシンクまでの最小費用（単位コストとフローの積の総和）を求める．",
			"    // 返り値は流量とコスト．O(F*|E|*log|V|).",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t, Flow flow) {",
			"        assert(0 <= s and s < m_vn);",
			"        assert(0 <= t and t < m_vn);",
			"        init();",
			"        Flow rest = flow;",
			"        Cost sum = 0;",
			"        while(rest > 0) {",
			"            dijkstra(s);",
			"            if(m_level[t] == m_inf) return {flow - rest, sum};  // これ以上流せない場合．",
			"            for(int v = 0; v < m_vn; ++v) m_p[v] -= m_level[v];",
			"            Flow tmp = rest;",
			"            for(int v = t; v != s; v = m_prevv[v]) tmp = std::min(tmp, m_g[m_prevv[v]][m_preve[v]].cap);",
			"            rest -= tmp;",
			"            sum += (-m_p[t]) * tmp;",
			"            for(int v = t; v != s; v = m_prevv[v]) {",
			"                Edge &e = m_g[m_prevv[v]][m_preve[v]];",
			"                e.cap -= tmp;",
			"                m_g[v][e.rev].cap += tmp;",
			"            }",
			"        }",
			"        return {flow, sum};",
			"    }",
			"};"
		],
		"description": "最小費用流問題"
	},
	"SCC": {
		"scope": "cpp",
		"prefix": "SCC",
		"body": [
			"// 強連結成分分解 (SCC:Strongly Connected Components)．",
			"class SCC {",
			"    int m_vn;                            // m_vn:=(ノード数).",
			"    std::vector<std::vector<int> > m_g;  // m_g[v][]:=(頂点vの隣接リスト).",
			"",
			"public:",
			"    SCC() : SCC(0) {}",
			"    explicit SCC(int vn) : m_vn(vn), m_g(vn) {}",
			"",
			"    // 頂点数を返す．",
			"    int size() const { return m_vn; }",
			"    // 有向辺を張る．",
			"    void add_edge(int from, int to) {",
			"        assert(0 <= from and from < m_vn);",
			"        assert(0 <= to and to < m_vn);",
			"        m_g[from].push_back(to);",
			"    }",
			"    // return pair of (# of SCCs, SCC id).",
			"    std::pair<int, std::vector<int> > get_scc_id() const {",
			"        std::vector<int> ord(m_vn, -1), low(m_vn), ids(m_vn);",
			"        int now_ord = 0, num_groups = 0;",
			"        std::stack<int> visited;",
			"        auto dfs = [&](auto self, int v) -> void {",
			"            ord[v] = low[v] = now_ord++;",
			"            visited.push(v);",
			"            for(auto to : m_g[v]) {",
			"                if(ord[to] == -1) {",
			"                    self(self, to);",
			"                    low[v] = std::min(low[v], low[to]);",
			"                } else {",
			"                    low[v] = std::min(low[v], ord[to]);",
			"                }",
			"            }",
			"            if(low[v] == ord[v]) {",
			"                while(true) {",
			"                    auto u = visited.top();",
			"                    visited.pop();",
			"                    ord[u] = m_vn;",
			"                    ids[u] = num_groups;",
			"                    if(u == v) break;",
			"                }",
			"                num_groups++;",
			"            }",
			"        };",
			"        for(int v = 0; v < m_vn; ++v) {",
			"            if(ord[v] == -1) dfs(dfs, v);",
			"        }",
			"        for(auto &x : ids) x = num_groups - 1 - x;",
			"        return {num_groups, ids};",
			"    }",
			"    // 有向グラフを強連結成分分解する．",
			"    std::vector<std::vector<int> > decompose() const {",
			"        const auto &&[num_groups, ids] = get_scc_id();",
			"        std::vector<int> counts(num_groups, 0);",
			"        for(auto x : ids) counts[x]++;",
			"        std::vector<std::vector<int> > sccs(num_groups);",
			"        for(int i = 0; i < num_groups; ++i) sccs[i].reserve(counts[i]);",
			"        for(int v = 0; v < m_vn; ++v) sccs[ids[v]].push_back(v);",
			"        return sccs;",
			"    }",
			"};"
		],
		"description": "強連結成分分解 (SCC:Strongly Connected Components)"
	},
	"SegmentSieve": {
		"scope": "cpp",
		"prefix": "SegmentSieve",
		"body": [
			"// 区間篩．",
			"class SegmentSieve {",
			"    long long l, r;",
			"    long long sr;                                  // sr:=√r.",
			"    std::vector<long long> small;                  // small[n]:=(区間[2,√r)の自然数nの最小の素因数).",
			"    std::vector<std::map<long long, int> > large;  // large[n-l][]:=(区間[l,r)の自然数nの区間[2,√r)における素因数).",
			"    std::vector<long long> aux;                    // aux[n-l]:=(large[n-l][]の積).",
			"",
			"    void build() {",
			"        sr = std::sqrt(r) + 5;",
			"        small.assign(sr, -1);",
			"        for(long long p = 2; p < sr; ++p) small[p] = p;",
			"        large.resize(r - l);",
			"        aux.assign(r - l, 1);",
			"        for(long long p = 2; p * p < r; ++p) {",
			"            if(small[p] == p) {",
			"                for(long long n = p * p; n < sr; n += p) small[n] = p;",
			"                for(long long n = std::max<long long>(2, (l + p - 1) / p) * p; n < r; n += p) {",
			"                    long long tmp = n;",
			"                    while(tmp % p == 0 and aux[n - l] * aux[n - l] <= r) {",
			"                        large[n - l][p]++;",
			"                        aux[n - l] *= p;",
			"                        tmp /= p;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. 区間[l,r)の自然数を篩にかける．制約の目安は大体 2<=l<r<=1e12, r-l<=1e6．",
			"    SegmentSieve() : SegmentSieve(2, 3) {}",
			"    explicit SegmentSieve(long long l_, long long r_) : l(l_), r(r_) {",
			"        assert(2 <= l and l < r);",
			"        build();",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(long long n) const {",
			"        assert(l <= n and n < r);",
			"        return large[n - l].size() == 0;",
			"    }",
			"    // 高速素因数分解．",
			"    std::map<long long, int> prime_factorize(long long n) const {",
			"        assert(l <= n and n < r);",
			"        std::map<long long, int> res = large[n - l];",
			"        n /= aux[n - l];",
			"        if(n >= sr) {",
			"            res[n]++;",
			"            return res;",
			"        }",
			"        while(n > 1) {",
			"            res[small[n]]++;",
			"            n /= small[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<long long> divisors(long long n) const {",
			"        assert(l <= n and n < r);",
			"        std::vector<long long> res({1});",
			"        if(n == 1) return res;",
			"        const auto &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            long long b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[i] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"};"
		],
		"description": "区間篩"
	},
	"SegmentTree": {
		"scope": "cpp",
		"prefix": "SegmentTree",
		"body": [
			"template <typename T>",
			"class SegmentTree {",
			"    using F = std::function<T(T, T)>;",
			"",
			"    F op;                 // T op(T,T):=(二項演算関数).",
			"    T e;                  // e:=(単位元).",
			"    int sz;               // sz:=(要素数).",
			"    int n;                // n:=(葉の数).",
			"    std::vector<T> tree;  // tree[]:=(完全二分木). 1-based index.",
			"",
			"    void build() {",
			"        n = 1;",
			"        while(n < sz) n <<= 1;",
			"        tree.assign(2 * n, e);",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    SegmentTree(){};",
			"    explicit SegmentTree(const F &op_, const T &e_, size_t sz_) : op(op_), e(e_), sz(sz_) {",
			"        build();",
			"    }",
			"    explicit SegmentTree(const F &op_, const T &e_, std::vector<T> &v) : op(op_), e(e_), sz(v.size()) {",
			"        build();",
			"        std::copy(v.begin(), v.end(), tree.begin() + n);",
			"        for(int i = n - 1; i >= 1; --i) tree[i] = op(tree[i << 1], tree[(i << 1) | 1]);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return sz; }",
			"    // 単位元を返す．",
			"    T identity() const { return e; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const T &a) {",
			"        assert(0 <= k and k < sz);",
			"        k += n;",
			"        tree[k] = a;",
			"        while(k >>= 1) tree[k] = op(tree[k << 1], tree[(k << 1) | 1]);",
			"    }",
			"    // k番目の要素をaを加える．O(logN).",
			"    void add(int k, const T &a) {",
			"        assert(0 <= k and k < sz);",
			"        k += n;",
			"        tree[k] += a;",
			"        while(k >>= 1) tree[k] = op(tree[k << 1], tree[(k << 1) | 1]);",
			"    }",
			"    // 一点取得．O(1).",
			"    T prod(int k) const {",
			"        assert(0 <= k and k < sz);",
			"        return tree[k + n];",
			"    }",
			"    // 区間[l,r)の総積（v[l]•v[l+1]•....•v[r-1]）を求める．O(logN).",
			"    T prod(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= sz);",
			"        T lv = e, rv = e;",
			"        l += n, r += n;",
			"        while(l < r) {",
			"            if(l & 1) lv = op(lv, tree[l++]);",
			"            if(r & 1) rv = op(tree[--r], rv);",
			"            l >>= 1, r >>= 1;",
			"        }",
			"        return op(lv, rv);",
			"    }",
			"    // 区間全体の総積を返す．O(1).",
			"    T prod_all() const { return tree[1]; }",
			"    // jud(prod(l,-))=trueとなる区間の最右位値を二分探索する．",
			"    // ただし要素列には単調性があり，またjud(e)=trueであること．O(logN).",
			"    int most_right(const std::function<bool(T)> &jud, int l) const {",
			"        assert(jud(e) == true);",
			"        assert(0 <= l and l <= sz);",
			"        if(l == sz) return sz;",
			"        T val = e;",
			"        l += n;",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            T &&tmp = op(val, tree[l]);",
			"            if(!jud(tmp)) {",
			"                while(l < n) {",
			"                    l <<= 1;",
			"                    T &&tmp2 = op(val, tree[l]);",
			"                    if(jud(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==xのとき，xは2の階乗数．",
			"        return sz;",
			"    }",
			"    // jud(prod(-,r))=trueとなる区間の最左位値を二分探索する．",
			"    // ただし要素列には単調性があり，またjud(e)=trueであること．O(logN).",
			"    int most_left(const std::function<bool(T)> &jud, int r) const {",
			"        assert(jud(e) == true);",
			"        assert(0 <= r and r <= sz);",
			"        if(r == 0) return 0;",
			"        T val = e;",
			"        r += n;",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            T &&tmp = op(tree[r], val);",
			"            if(!jud(tmp)) {",
			"                while(r < n) {",
			"                    r = (r << 1) | 1;",
			"                    T &&tmp2 = op(tree[r], val);",
			"                    if(jud(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==xのとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() { std::fill(tree.begin(), tree.end(), e); }",
			"};"
		],
		"description": ""
	},
	"SerialSet": {
		"scope": "cpp",
		"prefix": "SerialSet",
		"body": [
			"// 連続した整数列の集合を管理するデータ構造．",
			"template <typename T>",
			"class SerialSet {",
			"    std::set<std::pair<T, T> > m_st;  // m_st:=(整数の集合). 連続する整数列[l,r)をpair(l,r)で表現する．",
			"    T m_inf;",
			"",
			"public:",
			"    // constructor.",
			"    explicit SerialSet(T inf = 1e9) : m_inf(inf) {",
			"        m_st.emplace(-m_inf, -m_inf + 1);  // 番兵用．",
			"        m_st.emplace(m_inf, m_inf + 1);    // 〃",
			"    }",
			"",
			"    T infinity() const { return m_inf; }",
			"    // 整数xを挿入する．",
			"    bool insert(T x) { return insert(x, x + 1); }",
			"    // 整数列[l,r)を挿入する．O(logN).",
			"    bool insert(T l, T r) {",
			"        assert(-m_inf < l and l < r and r <= m_inf);",
			"        auto itr1 = std::prev(m_st.lower_bound(std::pair<T, T>(l + 1, l + 2)));",
			"        auto [l1, r1] = *itr1;",
			"        if(r <= r1) return false;  // 集合に完全に含まれている場合．",
			"        auto itr3 = m_st.lower_bound(std::pair<T, T>(r, r + 1));",
			"        auto itr2 = std::prev(itr3);",
			"        auto [l2, r2] = *itr2;",
			"        auto [l3, r3] = *itr3;",
			"        if(l <= r1)",
			"            l = l1;",
			"        else",
			"            itr1++;",
			"        if(l3 <= r) {",
			"            m_st.erase(itr1, ++itr3);",
			"            m_st.emplace(l, r3);",
			"        } else {",
			"            m_st.erase(itr1, itr3);",
			"            if(r <= r2)",
			"                m_st.emplace(l, r2);",
			"            else",
			"                m_st.emplace(l, r);",
			"        }",
			"        return true;",
			"    }",
			"    // 整数xを削除する．",
			"    bool erase(T x) { return erase(x, x + 1); }",
			"    // 範囲[l,r)の整数列を削除する．O(logN).",
			"    bool erase(T l, T r) {",
			"        assert(-m_inf < l and l < r and r <= m_inf);",
			"        auto itr1 = std::prev(m_st.lower_bound(std::pair<T, T>(l + 1, l + 2)));",
			"        auto itr3 = m_st.lower_bound(std::pair<T, T>(r, r + 1));",
			"        auto itr2 = std::prev(itr3);",
			"        auto [l1, r1] = *itr1;",
			"        auto [l2, r2] = *itr2;",
			"        if(l < r1) {",
			"            m_st.erase(itr1, itr3);",
			"            if(l1 < l) m_st.emplace(l1, l);",
			"        } else {",
			"            if(itr1 == itr2) return false;  // 集合に全く含まれていない場合．",
			"            m_st.erase(++itr1, itr3);",
			"        }",
			"        if(r < r2) m_st.emplace(r, r2);",
			"        return true;",
			"    }",
			"    // 整数xが集合に含まれるか判定する．",
			"    bool contains(T x) const { return contains(x, x + 1); }",
			"    // 整数列[l,r)が集合に完全に含まれるか判定する．(logN).",
			"    bool contains(T l, T r) const {",
			"        assert(-m_inf < l and l < r and r <= m_inf);",
			"        const auto &[_, pr] = *std::prev(m_st.lower_bound(std::pair<T, T>(l + 1, l + 2)));",
			"        return r <= pr;",
			"    }",
			"    // 集合に含まれないx以上の整数の中で最小の値 (MEX:Minimum EXcluded value) を求める．O(logN).",
			"    T mex(T x) const {",
			"        assert(-m_inf < x and x < m_inf);",
			"        const auto &[_, r] = *std::prev(m_st.lower_bound(std::pair<T, T>(x + 1, x + 2)));",
			"        return (x < r ? r : x);",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const SerialSet &ob) {",
			"        for(const auto &[l, r] : ob.m_st) os << \"[\" << l << \", \" << r << \") \";",
			"        os << std::endl;",
			"    }",
			"};"
		],
		"description": "連続した整数列の集合を管理するデータ構造"
	},
	"Sieve": {
		"scope": "cpp",
		"prefix": "Sieve",
		"body": [
			"// エラトステネスの篩．",
			"class Sieve {",
			"    int m_mx;                // m_mx:=(篩にかける最大の自然数).",
			"    std::vector<int> m_lpf;  // m_lpf[n]:=(自然数nの最小の素因数). Least prime factor. m_lpf[n]==n のとき，nは素数．",
			"",
			"    int internal_pow(int n, unsigned int k) const {",
			"        if(k == 0) return 1;",
			"        auto &&res = internal_pow(n * n, k >> 1);",
			"        if(k & 1U) res *= n;",
			"        return res;",
			"    }",
			"",
			"public:",
			"    // constructor. mx以下の自然数を篩にかける．O(N*loglogN).",
			"    Sieve() : Sieve(51e4) {}",
			"    explicit Sieve(int mx) : m_mx(mx), m_lpf(mx + 1, -1) {",
			"        assert(mx >= 0);",
			"        for(int p = 2; p <= m_mx; ++p) m_lpf[p] = p;",
			"        for(int p = 2; p * p <= m_mx; ++p) {",
			"            if(m_lpf[p] == p) {",
			"                for(int n = p * p; n <= m_mx; n += p) {",
			"                    if(m_lpf[n] == n) m_lpf[n] = p;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小の素因数を返す．O(1).",
			"    int get_lpf(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const auto &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[i] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    // オイラーのファイ関数．n以下でnと互いに素な自然数の個数．",
			"    int totient(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        const auto &&pf = prime_factorize(n);",
			"        int res = 1;",
			"        for(const auto &[p, cnt] : pf) res *= internal_pow(p, cnt - 1) * (p - 1);",
			"        return res;",
			"    }",
			"};"
		],
		"description": "エラトステネスの篩"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "UnionFind",
		"body": [
			"// 素集合データ構造．",
			"class UnionFind {",
			"    int m_vn;                // m_vn:=(ノード数).",
			"    int m_gn;                // m_gn:=(グループ数).",
			"    std::vector<int> m_par;  // m_par[v]:=(ノードvの親番号). 0未満の場合，vは親で，値の絶対値はグループサイズを表す．",
			"",
			"public:",
			"    // constructor.",
			"    UnionFind() : UnionFind(0) {}",
			"    explicit UnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // ノード数を返す．",
			"    int get_vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int get_gn() const { return m_gn; };",
			"    // ノードvの親番号を返す．",
			"    int root(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        if(m_par[v] < 0) return v;",
			"        return m_par[v] = root(m_par[v]);",
			"    }",
			"    // ノードvが属するグループのサイズを返す．",
			"    int size(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        return -m_par[root(v)];",
			"    }",
			"    // ノードuとvが同じグループか判定する．",
			"    bool same(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        return root(u) == root(v);",
			"    }",
			"    // ノードu, vが属するそれぞれのグループを結合する．",
			"    bool unite(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        u = root(u), v = root(v);",
			"        if(u == v) return false;                // Do nothing.",
			"        if(size(u) < size(v)) std::swap(u, v);  // Merge technique.",
			"        m_par[u] += m_par[v];",
			"        m_par[v] = u;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = m_vn;",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"    }",
			"};"
		],
		"description": "素集合データ構造"
	},
	"bit_count": {
		"scope": "cpp",
		"prefix": "bit_count",
		"body": [
			"int bit_count32(uint32_t n) {",
			"    const uint32_t masks[5] = {0x55555555U, 0x33333333U, 0x0f0f0f0fU, 0x00ff00ffU, 0x0000ffffU};",
			"    for(int i = 0; i < 5; ++i) n = (n & masks[i]) + ((n >> (1U << i)) & masks[i]);",
			"    return n;",
			"}",
			"",
			"int bit_count64(uint64_t n) {",
			"    const uint64_t masks[6] = {0x5555555555555555ULL, 0x3333333333333333ULL, 0x0f0f0f0f0f0f0f0fULL,",
			"                               0x00ff00ff00ff00ffULL, 0x0000ffff0000ffffULL, 0x00000000ffffffffULL};",
			"    for(int i = 0; i < 6; ++i) n = (n & masks[i]) + ((n >> (1ULL << i)) & masks[i]);",
			"    return n;",
			"}"
		],
		"description": "ビットカウント"
	},
	"calc_divisor": {
		"scope": "cpp",
		"prefix": "calc_divisor",
		"body": [
			"// 約数列挙．O(√N).",
			"template <typename Type>",
			"std::vector<Type> calc_divisor(Type n) {",
			"    assert(n >= 0);",
			"    std::vector<Type> res;  // res[]:=(自然数nの約数の集合).",
			"    for(Type p = 1; p * p <= n; ++p) {",
			"        if(n % p == 0) {",
			"            res.push_back(p);",
			"            Type q = n / p;",
			"            if(q != p) res.push_back(q);",
			"        }",
			"    }",
			"    std::sort(res.begin(), res.end());",
			"    return res;",
			"}"
		],
		"description": "約数列挙"
	},
	"chmin, chmax": {
		"scope": "cpp",
		"prefix": "chmin, chmax",
		"body": [
			"template<typename Type> inline bool chmin(Type &a,const Type &b){if(a>b){a=b;return true;}return false;}",
			"template<typename Type> inline bool chmax(Type &a,const Type &b){if(a<b){a=b;return true;}return false;}"
		],
		"description": ""
	},
	"chtoupper, chtolower": {
		"scope": "cpp",
		"prefix": "chtoupper, chtolower",
		"body": [
			"inline bool chtoupper(char &c){if('a'<=c && c<='z'){c-=0x20;return true;}return false;}",
			"inline bool chtolower(char &c){if('A'<=c && c<='Z'){c+=0x20;return true;}return false;}"
		],
		"description": ""
	},
	"compress": {
		"scope": "cpp",
		"prefix": "compress",
		"body": [
			"// 座標圧縮．",
			"template <typename Type>",
			"std::vector<Type> compress(std::vector<Type> &v) {",
			"    const int n = v.size();",
			"    std::vector<Type> res = v;",
			"    std::sort(res.begin(), res.end());",
			"    res.erase(std::unique(res.begin(), res.end()), res.end());",
			"    for(int i = 0; i < n; ++i) v[i] = std::lower_bound(res.begin(), res.end(), v[i]) - res.begin();",
			"    return res;",
			"}"
		],
		"description": "座標圧縮"
	},
	"dot, cross": {
		"scope": "cpp",
		"prefix": "dot, cross",
		"body": [
			"template<typename Type> inline Type dot(Type x1,Type y1,Type x2,Type y2){return x1*x2+y1*y2;}",
			"template<typename Type> inline Type dot(const std::pair<Type,Type> &p,const std::pair<Type,Type> &q){return p.first*q.first+p.second*q.second;}",
			"template<typename Type> inline Type dot(Type x,Type y){return x*x+y*y;}",
			"template<typename Type> inline Type dot(const std::pair<Type,Type> &p){return p.first*p.first+p.second*p.second;}",
			"template<typename Type> inline Type cross(Type x1,Type y1,Type x2,Type y2){return x1*y2-y1*x2;}",
			"template<typename Type> inline Type cross(const std::pair<Type,Type> &p,const std::pair<Type,Type> &q){return p.first*q.second-p.second*q.first;}"
		],
		"description": "内積，外積"
	},
	"edit_distance": {
		"scope": "cpp",
		"prefix": "edit_distance",
		"body": [
			"// 編集距離 (edit distance)．引数はSTLのシーケンスコンテナ．O(|A|*|B|).",
			"template <class Class>",
			"int edit_distance(const Class &a, const Class &b) {",
			"    const int n = a.size(), m = b.size();",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1));  // dp[i][j]:=(a[:i]とb[:j]の編集距離).",
			"    dp[0][0] = 0;",
			"    for(int i = 1; i <= n; ++i) dp[i][0] = i;",
			"    for(int j = 1; j <= m; ++j) dp[0][j] = j;",
			"    for(int i = 1; i <= n; ++i)",
			"        for(int j = 1; j <= m; ++j) dp[i][j] = std::min({dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + (a[i - 1] == b[j - 1] ? 0 : 1)});",
			"    return dp[n][m];",
			"}"
		],
		"description": "編集距離 (edit distance)"
	},
	"extgcd, crt": {
		"scope": "cpp",
		"prefix": "extgcd, crt",
		"body": [
			"// 拡張ユークリッド互除法．ax+by=GCD(a,b) を満たす整数の組(x,y)を格納する．O(logN).",
			"template <typename Type>",
			"Type extgcd(Type a, Type b, Type &x, Type &y) {",
			"    if(b == 0) {",
			"        x = 1, y = 0;",
			"        return a;",
			"    }",
			"    Type d = extgcd(b, a % b, y, x);",
			"    y -= a / b * x;",
			"    return d;",
			"}",
			"",
			"// 中国剰余定理 (Chinese Remainder Theorem)．",
			"//　x≡r[i] (mod. m[i]) の解を x≡R (mod. M) として {R,M} を求める．解なしのときは {0,-1}．",
			"std::pair<long long, long long> crt(const std::vector<long long> &vr, const std::vector<long long> &vm) {",
			"    assert(vr.size() == vm.size());",
			"    if(vr.empty()) return {0, 1};",
			"    const int n = vr.size();",
			"    long long r = vr[0], m = vm[0];",
			"    for(int i = 1; i < n; ++i) {",
			"        long long p, q, tr = vr[i], tm = vm[i];",
			"        if(m < tm) std::swap(r, tr), std::swap(m, tm);  // prevent overflow.",
			"        long long d = extgcd(m, tm, p, q);              // p is inv of m/d (mod. m/d).",
			"        if((tr - r) % d != 0) return {0, -1};",
			"        long long md = m / d;",
			"        long long tmp = (tr - r) / d % md * p % md;",
			"        r += m * tmp, m *= md;",
			"    }",
			"    r %= m;",
			"    if(r < 0) r += m;",
			"    return {r, m};",
			"}"
		],
		"description": "拡張ユークリッド互除法，中国剰余定理 (Chinese Remainder Theorem)"
	},
	"floor_sum": {
		"scope": "cpp",
		"prefix": "floor_sum",
		"body": [
			"// sum_{x=0}^{n-1} floor((a*x+b)/m)を求める．O(loga+logm).",
			"long long floor_sum(long long n, long long m, long long a, long long b) {",
			"    assert(0 <= n and n < (1LL << 32));",
			"    assert(1 <= m and m < (1LL << 32));",
			"    long long res = 0;",
			"    if(a < 0) {",
			"        long long a2 = (a % m + m) % m;",
			"        res -= n * (n - 1) / 2 * ((a2 - a) / m);",
			"        a = a2;",
			"    }",
			"    if(b < 0) {",
			"        long long b2 = (b % m + m) % m;",
			"        res -= n * ((b2 - b) / m);",
			"        b = b2;",
			"    }",
			"    if(a >= m) {",
			"        res += n * (n - 1) / 2 * (a / m);",
			"        a %= m;",
			"    }",
			"    if(b >= m) {",
			"        res += n * (b / m);",
			"        b %= m;",
			"    }",
			"    long long y_max = a * n + b;",
			"    if(y_max >= m) res += floor_sum(y_max / m, a, m, y_max % m);",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"igcd, ilcm": {
		"scope": "cpp",
		"prefix": "igcd, ilcm",
		"body": [
			"template<typename Type> Type igcd(Type a,Type b){return (b==0)?a:igcd(b,a%b);}",
			"template<typename Type> Type ilcm(Type a,Type b){return a/igcd(a,b)*b;}"
		],
		"description": "最大公約数，最小公倍数"
	},
	"ipow": {
		"scope": "cpp",
		"prefix": "ipow",
		"body": [
			"// 繰返し二乗法．O(logK).",
			"long long ipow(long long n, long long k) {",
			"    assert(k >= 0);",
			"    if(k == 0) return 1;",
			"    long long &&res = ipow(n * n, k >> 1);",
			"    if(k & 1LL) res *= n;",
			"    return res;",
			"}"
		],
		"description": "繰返し二乗法"
	},
	"isqrt": {
		"scope": "cpp",
		"prefix": "isqrt",
		"body": [
			"// 平方根（ニュートン法）．",
			"double isqrt(double x, const double eps = 1e-10) {",
			"    assert(x >= 0.0);",
			"    double res = 5.0;",
			"    while(1) {",
			"        double tmp = (x / res + res) / 2;",
			"        if(std::abs(tmp - res) < eps) break;",
			"        res = tmp;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "平方根（ニュートン法）"
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"// 素数判定．O(√N).",
			"bool is_prime(long long n) {",
			"    if(n < 2) return false;",
			"    for(long long p = 2; p * p <= n; ++p) {",
			"        if(n % p == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"lcs": {
		"scope": "cpp",
		"prefix": "lcs",
		"body": [
			"// 最長共通部分列 (LCS:Longest Common Subsequence)．引数はSTLのシーケンスコンテナ．O(|A|*|B|).",
			"template <class Class>",
			"Class lcs(const Class &a, const Class &b) {",
			"    const int n = a.size(), m = b.size();",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));  // dp[i][j]:=(a[:i]とb[:j]のLCSの長さ).",
			"    for(int i = 1; i <= n; ++i)",
			"        for(int j = 1; j <= m; ++j) {",
			"            if(a[i - 1] == b[j - 1])",
			"                dp[i][j] = dp[i - 1][j - 1] + 1;",
			"            else",
			"                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);",
			"        }",
			"    Class sub(dp[n][m]);  // sub[]:=(配列a, bのLCS).",
			"    int i = n, j = m, k = dp[n][m];",
			"    while(k > 0) {",
			"        if(a[i - 1] == b[j - 1]) {",
			"            sub[k - 1] = a[i - 1];",
			"            i--, j--, k--;",
			"        } else if(dp[i][j] == dp[i - 1][j]) {",
			"            i--;",
			"        } else {",
			"            j--;",
			"        }",
			"    }",
			"    return sub;",
			"}"
		],
		"description": "最長共通部分列 (LCS:Longest Common Subsequence)"
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"// 最長増加部分列 (LIS:Longest Increasing Subsequence) の長さを求める．引数はSTLのシーケンスコンテナ．O(|A|*log|A|).",
			"template <class Class>",
			"int lis(const Class &a, bool is_strong = true) {",
			"    Class dp({a[0]});",
			"    for(int i = 1; i < a.size(); ++i) {",
			"        if(is_strong) {  // 狭義単調増加．",
			"            if(dp[dp.size() - 1] < a[i])",
			"                dp.push_back(a[i]);",
			"            else",
			"                *lower_bound(dp.begin(), dp.end(), a[i]) = a[i];",
			"        } else {  // 広義単調増加．",
			"            if(dp[dp.size() - 1] <= a[i])",
			"                dp.push_back(a[i]);",
			"            else",
			"                *upper_bound(dp.begin(), dp.end(), a[i]) = a[i];",
			"        }",
			"    }",
			"    return dp.size();",
			"}"
		],
		"description": "最長増加部分列 (LIS:Longest Increasing Subsequence)"
	},
	"mod_inv": {
		"scope": "cpp",
		"prefix": "mod_inv",
		"body": [
			"// 逆元．a^-1 (mod m)を求める（ただし，aとmは互いに素）．",
			"long long mod_inv(long long a, int m) {",
			"    // assert(m >= 1 and std::gcd(a, m) == 1);",
			"    assert(m >= 1);",
			"    long long b = m, u = 1, v = 0;",
			"    while(b) {",
			"        long long t = a / b;",
			"        a -= t * b, u -= t * v;",
			"        std::swap(a, b), std::swap(u, v);",
			"    }",
			"    return (u % m + m) % m;",
			"}"
		],
		"description": "逆元"
	},
	"mod_pow": {
		"scope": "cpp",
		"prefix": "mod_pow",
		"body": [
			"// 繰返し二乗法（mod付き）．n^k (mod m)を求める．O(logK).",
			"long long mod_pow(long long n, long long k, int m) {",
			"    assert(k >= 0 and m >= 1);",
			"    n %= m;",
			"    long long res = 1;",
			"    while(k > 0) {",
			"        if(k & 1LL) res = res * n % m;",
			"        n = n * n % m;",
			"        k >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "繰返し二乗法（mod付き）"
	},
	"prime_factorize": {
		"scope": "cpp",
		"prefix": "prime_factorize",
		"body": [
			"// 素因数分解．O(√N).",
			"template <typename Type>",
			"std::map<Type, int> prime_factorize(Type n) {",
			"    assert(n >= 2);",
			"    std::map<Type, int> mp;  // mp[p]:=(自然数nに含まれる素因数pの個数).",
			"    for(Type p = 2; p * p <= n; ++p) {",
			"        if(n % p != 0) continue;",
			"        while(n % p == 0) mp[p]++, n /= p;",
			"    }",
			"    if(n != 1) mp[n]++;",
			"    return mp;",
			"}"
		],
		"description": "素因数分解"
	},
	"split": {
		"scope": "cpp",
		"prefix": "split",
		"body": [
			"// 文字列分割．指定の文字delimで分割する．",
			"std::vector<std::string> split(const std::string &s, char delim) {",
			"    std::vector<std::string> res;",
			"    std::stringstream ss(s);",
			"    std::string item;",
			"    while(std::getline(ss, item, delim)) {",
			"        if(!item.empty()) res.push_back(item);",
			"    }",
			"    return res;",
			"}"
		],
		"description": "文字列分割"
	},
	"stov, vtos": {
		"scope": "cpp",
		"prefix": "stov, vtos",
		"body": [
			"std::vector<int> stov(const std::string &s) {",
			"    const int n = s.size();",
			"    std::vector<int> v(n);",
			"    for(int i = 0; i < n; ++i) v[i] = s[i];",
			"    return v;",
			"}",
			"",
			"std::string vtos(const std::vector<int> &v) {",
			"    const int n = v.size();",
			"    std::string s(n, 0);",
			"    for(int i = 0; i < n; ++i) {",
			"        assert(0 <= v[i] and v[i] < 128);",
			"        s[i] = v[i];",
			"    }",
			"    return s;",
			"}"
		],
		"description": ""
	},
	"string_modulo": {
		"scope": "cpp",
		"prefix": "string_modulo",
		"body": [
			"// 文字列剰余．O(|S|).",
			"long long string_modulo(const std::string &s, const int mod) {",
			"    const int n = s.size();",
			"    long long res = 0;",
			"    for(int i = 0; i < n; ++i) {",
			"        assert('0' <= s[i] and s[i] <= '9');",
			"        res = (10 * res + (s[i] - '0')) % mod;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "文字列剰余"
	},
	"table": {
		"scope": "cpp",
		"prefix": "table",
		"body": [
			"template <typename Type>",
			"std::vector<Type> table(size_t n, Type val) { return std::vector<Type>(n, val); }",
			"",
			"template <class... Args>",
			"auto table(size_t n, Args &&...args) {",
			"    auto val = table(std::forward<Args>(args)...);",
			"    return std::vector<decltype(val)>(n, std::move(val));",
			"}"
		],
		"description": "多次元配列生成"
	},
	"z_algorithm": {
		"scope": "cpp",
		"prefix": "z_algorithm",
		"body": [
			"// 最長共通接頭辞 (LCP:Longest Common Prefix)．O(|S|).",
			"template <class Class>",
			"std::vector<int> z_algorithm(const Class &s) {",
			"    const int n = s.size();",
			"    std::vector<int> z(n);  // z[i]:=(sとs[i:]のLCPの長さ).",
			"    z[0] = n;",
			"    int i = 1, j = 0;",
			"    while(i < n) {",
			"        while(i + j < n and s[j] == s[i + j]) j++;",
			"        z[i] = j;",
			"        if(j == 0) {",
			"            i++;",
			"            continue;",
			"        }",
			"        int k = 1;",
			"        while(i + k < n and z[k] + k < j) {",
			"            z[i + k] = z[k];",
			"            k++;",
			"        }",
			"        i += k, j -= k;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "最長共通接頭辞 (LCP:Longest Common Prefix)"
	},
	"geometry Vector": {
		"scope": "cpp",
		"prefix": "geometry Vector",
		"body": [
			"namespace geometry {",
			"",
			"using Type = double;",
			"",
			"const Type INF = 1e18;",
			"const Type EPS = 1e-10;",
			"const Type PI = std::acos(-1.0);",
			"",
			"inline bool equal_to(const Type &a, const Type &b) { return std::abs(a - b) < EPS; }",
			"inline bool less_than(const Type &a, const Type &b) { return a - b < -EPS; }",
			"inline bool more_than(const Type &a, const Type &b) { return a - b > EPS; }",
			"inline bool no_more(const Type &a, const Type &b) { return a - b < EPS; }",
			"inline bool no_less(const Type &a, const Type &b) { return a - b > -EPS; }",
			"",
			"inline Type to_radian(Type deg) { return deg / 180.0 * PI; }",
			"inline Type to_degree(Type rad) { return rad / PI * 180.0; }",
			"",
			"struct Vector {",
			"    Type x, y;",
			"",
			"    Vector() : Vector(0.0, 0.0) {}",
			"    Vector(Type x_, Type y_) : x(x_), y(y_) {}",
			"",
			"    Vector operator+() const { return Vector(*this); }",
			"    Vector operator-() const { return Vector(-x, -y); }",
			"    Vector operator*(Type n) const { return Vector(x * n, y * n); }",
			"    Vector operator/(Type n) const { return Vector(x / n, y / n); }",
			"    Vector &operator*=(Type n) {",
			"        x *= n, y *= n;",
			"        return *this;",
			"    }",
			"    Vector &operator/=(Type n) {",
			"        x /= n, y /= n;",
			"        return *this;",
			"    }",
			"    Vector &operator+=(const Vector &a) {",
			"        x += a.x, y += a.y;",
			"        return *this;",
			"    }",
			"    Vector &operator-=(const Vector &a) {",
			"        x -= a.x, y -= a.y;",
			"        return *this;",
			"    }",
			"",
			"    friend Vector operator*(Type n, const Vector &a) { return a * n; }",
			"    friend Vector operator+(const Vector &a, const Vector &b) { return Vector(a.x + b.x, a.y + b.y); }",
			"    friend Vector operator-(const Vector &a, const Vector &b) { return Vector(a.x - b.x, a.y - b.y); }",
			"    friend bool operator<(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? less_than(a.y, b.y) : less_than(a.x, b.x)); }",
			"    friend bool operator>(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? more_than(a.y, b.y) : more_than(a.x, b.x)); }",
			"    friend bool operator<=(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? no_more(a.y, b.y) : no_more(a.x, b.x)); }",
			"    friend bool operator>=(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? no_less(a.y, b.y) : no_less(a.x, b.x)); }",
			"    friend bool operator==(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) and equal_to(a.y, b.y)); }",
			"    friend bool operator!=(const Vector &a, const Vector &b) { return !(a == b); }",
			"    friend std::ostream &operator<<(std::ostream &os, const Vector &a) { return os << \"(\" << a.x << \", \" << a.y << \")\"; }",
			"",
			"    // ノルム．",
			"    Type norm() const { return std::sqrt(dot(*this, *this)); }",
			"    // 単位ベクトル．",
			"    Vector unit() const { return *this / norm(); }",
			"    // x軸となす角を返す．[-π, π].",
			"    Type arg() const { return std::atan2(y, x); }",
			"    // x軸となす角を返す．[0, 2π].",
			"    Type arg2() const {",
			"        Type res = arg();",
			"        if(less_than(res, 0.0)) res += PI;",
			"        return res;",
			"    }",
			"",
			"    // 内積．",
			"    friend inline Type dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y; }",
			"    // 外積．",
			"    friend inline Type cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x; }",
			"};",
			"",
			"using Point = Vector;",
			"using Polygon = std::vector<Point>;",
			"",
			"// 半時計回りに角度arg（ラジアン単位）回転させる．",
			"void rotate(Vector &a, Type arg) {",
			"    Type nx = a.x * std::cos(arg) - a.y * std::sin(arg);",
			"    Type ny = a.x * std::sin(arg) + a.y * std::cos(arg);",
			"    a.x = nx, a.y = ny;",
			"}",
			"inline void rotate90(Vector &a) { a = Vector(-a.y, a.x); }",
			"",
			"struct Complex : public Point {",
			"    Complex() : Point() {}",
			"    Complex(const Point &P) : Point(P) {}",
			"    Complex(Type x_, Type y_) : Point(x_, y_) {}",
			"",
			"    Complex &operator*=(const Complex &z) {",
			"        const auto [tx, ty] = *this;",
			"        x = tx * z.x - ty * z.y;",
			"        y = tx * z.y + ty * z.x;",
			"        return *this;",
			"    }",
			"    Complex &operator/=(const Complex &z) {",
			"        const auto [tx, ty] = *this;",
			"        x = tx * z.x - ty * z.y;",
			"        y = tx * z.y + ty * z.x;",
			"        return *this;",
			"    }",
			"",
			"    friend Complex operator*(const Complex &z, const Complex &w) { return Complex(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }",
			"    friend Complex operator/(const Complex &z, const Complex &w) { return Complex(z / (w.x * w.x + w.y * w.y)) * w; }",
			"",
			"    // 共役複素数．Conjugate complex number.",
			"    Complex conj() const { return Complex(x, -y); }",
			"};",
			"",
			"// 極形式．大きさr，偏角argの複素数を返す．",
			"inline Complex polar(Type r, Type arg) { return Complex(r * std::cos(arg), r * std::sin(arg)); }",
			"// 極形式(r,θ)に変換．θ∈[-π, π].",
			"inline std::pair<Type, Type> convert_polor(const Complex &z) { return {z.norm(), z.arg()}; }",
			"// 極形式(r,θ)に変換．θ∈[0, 2π].",
			"inline std::pair<Type, Type> convert_polor2(const Complex &z) { return {z.norm(), z.arg2()}; }",
			"",
			"}  // namespace geometry",
			"",
			"// using namespace geometry;"
		],
		"description": ""
	},
	"geometry figure": {
		"scope": "cpp",
		"prefix": "geometry figure",
		"body": [
			"namespace geometry {",
			"",
			"struct Line {",
			"    std::array<Point, 2> ps;",
			"",
			"    Line() : Line(Point(), Point()) {}",
			"    explicit Line(const Point &P, const Point &Q) : ps({P, Q}) {}",
			"",
			"    Point &operator[](int i) {",
			"        assert(0 <= i and i < 2);",
			"        return ps[i];",
			"    }",
			"    const Point &operator[](int i) const {",
			"        assert(0 <= i and i < 2);",
			"        return ps[i];",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const Line &s) { return os << \"{\" << s[0] << \", \" << s[1] << \"}\"; }",
			"",
			"    // 線分の長さ．",
			"    Type length() const { return Vector(ps[1] - ps[0]).norm(); }",
			"    // 直線の傾き．",
			"    Type slope() const { return (ps[1].y - ps[0].y) / (ps[1].x - ps[0].x); }",
			"    // y切片．",
			"    Type y_intercept() const { return ps[0].y - slope() * ps[0].x; }",
			"};",
			"",
			"using Segment = Line;",
			"",
			"struct Circle {",
			"    Point O;",
			"    Type r;",
			"",
			"    Circle() : O(Point()), r(1.0) {}",
			"    explicit Circle(Type r_) : O(Point()), r(r_) {}",
			"    explicit Circle(const Point &C_, Type r_) : O(C_), r(r_) {}",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const Circle &C) { return os << \"{O\" << C.O << \", r = \" << C.r << \"}\"; }",
			"",
			"    // 円周の長さ．",
			"    Type length() const { return 2 * r * PI; }",
			"    // 円の面積．",
			"    Type area() const { return r * r * PI; }",
			"};",
			"",
			"// 2点からの距離の比率m:nのアポロニウスの円．",
			"Circle apporonius(const Point &A, const Point &B, Type m, Type n) {",
			"    assert(!equal_to(m, n));",
			"    Point P = (n * A + m * B) / (m + n);",
			"    Point Q = (-n * A + m * B) / (m - n);",
			"    Point O = (P + Q) / 2;",
			"    Type r = Vector(P - O).norm();",
			"    return Circle(O, r);",
			"}",
			"",
			"}  // namespace geometry",
			"",
			"// using namespace geometry;"
		],
		"description": ""
	},
	"geometry function": {
		"scope": "cpp",
		"prefix": "geometry function",
		"body": [
			"namespace geometry {",
			"",
			"// 点と線分，直線，円の位置関係．",
			"",
			"int simple_ccw(const Point &A, const Point &B, const Point &P) {",
			"    Vector b = B - A, p = P - A;",
			"    if(more_than(cross(b, p), 0.0)) return 1;   // A->Bの反時計方向にP．",
			"    if(less_than(cross(b, p), 0.0)) return -1;  // A->Bの時計方向にP．",
			"    return 0;                                   // 一直線上．",
			"}",
			"int ccw(const Point &A, const Point &B, const Point &P) {",
			"    Vector b = B - A, p = P - A;",
			"    if(more_than(cross(b, p), 0.0)) return 1;      // A->Bの反時計方向にP．counter clockwise.",
			"    if(less_than(cross(b, p), 0.0)) return -1;     // A->Bの時計方向にP．clockwise.",
			"    if(more_than(dot(p, p), dot(b, b))) return 2;  // A->B->Pの順に一直線上．online front.",
			"    if(less_than(dot(b, p), 0.0)) return -2;       // P->A->Bの順に一直線上．online back.",
			"    return 0;                                      // A->P->Bの順に一直線上．on segment.",
			"}",
			"",
			"bool on_line(const Line &l, const Point &P) { return (simple_ccw(l[0], l[1], P) == 0); }",
			"bool on_segment(const Segment &s, const Point &P) { return (ccw(s[0], s[1], P) == 0); }",
			"",
			"// 垂線の足．",
			"Point projection(const Line &l, const Point &P) {",
			"    Vector a = (l[1] - l[0]);",
			"    return l[0] + a * (dot(P - l[0], a) / dot(a, a));",
			"}",
			"// 対象点．",
			"Point reflection(const Line &l, const Point &P) { return P + 2.0 * (projection(l, P) - P); }",
			"",
			"Type dist_ptop(const Point &P, const Point &Q) { return Vector(Q - P).norm(); }",
			"Type dist_ptol(const Point &P, const Line &l) {",
			"    Point H = projection(l, P);",
			"    return dist_ptop(P, H);",
			"}",
			"Type dist_ptos(const Point &P, const Segment &s) {",
			"    Point H = projection(s, P);",
			"    if(on_segment(s, H)) return dist_ptop(P, H);",
			"    return std::min(dist_ptop(P, s[0]), dist_ptop(P, s[1]));",
			"}",
			"",
			"// 三角形と点の包含関係．",
			"int contain(const Point &A, const Point &B, const Point &C, const Point &P) {",
			"    int flag1 = ccw(A, B, P), flag2 = ccw(B, C, P), flag3 = ccw(C, A, P);",
			"    if(flag1 == 0 or flag2 == 0 or flag3 == 0) return 1;       // on.",
			"    if(flag1 == 1 and flag2 == 1 and flag3 == 1) return 2;     // in.",
			"    if(flag1 == -1 and flag2 == -1 and flag3 == -1) return 2;  // in.",
			"    return 0;                                                  // out.",
			"}",
			"// 円と点の包含関係．",
			"int contain(const Circle &C, const Point &P) {",
			"    Type dif = dist_ptop(C.O, P) - C.r;",
			"    if(less_than(dif, 0.0)) return 2;  // in.",
			"    if(equal_to(dif, 0.0)) return 1;   // on.",
			"    return 0;                          // out.",
			"}",
			"",
			"// 直線の直交判定．",
			"bool jud_orthogonal(const Line &l, const Line &m) {",
			"    Vector b = l[1] - l[0], d = m[1] - m[0];",
			"    return equal_to(dot(b, d), 0.0);",
			"}",
			"// 直線の平行判定．",
			"bool jud_parallel(const Line &l, const Line &m) {",
			"    Vector b = l[1] - l[0], d = m[1] - m[0];",
			"    return equal_to(cross(b, d), 0.0);",
			"}",
			"// 線分の交点判定．",
			"bool jud_cross(const Segment &s, const Segment &t) {",
			"    Vector b = s[1] - s[0], c1 = t[0] - s[0], d1 = t[1] - s[0];",
			"    Vector a = s[0] - s[1], c2 = t[0] - s[1], d2 = t[1] - s[1];",
			"    return (no_more(cross(b, c1) * cross(b, d1), 0.0) and no_more(cross(a, c2) * cross(a, d2), 0.0));",
			"}",
			"",
			"// 線分，直線，円の交点を求める関数．",
			"",
			"std::vector<Point> cross_point(const Line &l, const Line &m) {",
			"    std::vector<Point> ps;",
			"    if(jud_parallel(l, m)) return ps;",
			"    Vector a = l[1] - l[0], b = m[1] - m[0];",
			"    ps.push_back(l[0] + a / cross(b, a) * cross(b, m[0] - l[0]));",
			"    return ps;",
			"}",
			"std::vector<Point> cross_point(const Circle &C, const Line &l) {",
			"    std::vector<Point> ps;",
			"    Point H = projection(l, C.O);",
			"    int flag = contain(C, H);",
			"    if(flag == 0) {",
			"    } else if(flag == 1) {",
			"        ps.push_back(H);",
			"    } else {",
			"        Type dist = dist_ptop(C.O, H);",
			"        Type arg = std::acos(dist / C.r);",
			"        ps.push_back(C.O + polar(C.r, arg));",
			"        ps.push_back(C.O + polar(C.r, -arg));",
			"    }",
			"    return ps;",
			"}",
			"std::vector<Point> cross_point(Circle C, Circle D) {",
			"    std::vector<Point> ps;",
			"    if(less_than(C.r, D.r)) std::swap(C, D);",
			"    Type dist = dist_ptop(C.O, D.O);",
			"    if(more_than(dist, C.r + D.r)) {  // 離れている場合．",
			"        // No points.",
			"    } else if(equal_to(dist, C.r + D.r)) {  // 外接する場合．",
			"        Vector base = Vector(D.O - C.O).unit();",
			"        ps.push_back(C.O + base * C.r);",
			"    } else if(less_than(std::abs(C.r - D.r), dist) and less_than(dist, C.r + D.r)) {  // 交差する場合．",
			"        Type tmp = C.r - (C.r + D.r - dist) / 2.0;",
			"        Type arg = std::acos(tmp / C.r);",
			"        ps.push_back(C.O + polar(C.r, arg));",
			"        ps.push_back(C.O + polar(C.r, -arg));",
			"    } else if(equal_to(dist, std::abs(C.r - D.r))) {  // 内接する場合．",
			"        Vector base = Vector(D.O - C.O).unit();",
			"        ps.push_back(C.O + base * C.r);",
			"    } else if(less_than(dist, std::abs(C.r - D.r))) {  // 内部にある場合．",
			"        // No points.",
			"    }",
			"    return ps;",
			"}",
			"",
			"// 多角形に関する関数，アルゴリズム．",
			"",
			"// 点を反時計周りにソート．O(NlogN).",
			"void vertices_sort(Polygon &pol) {",
			"    const int n = pol.size();",
			"    Polygon tmp = pol;",
			"    int p = 0;",
			"    for(int i = 1; i < n; ++i) {",
			"        if(less_than(tmp[i].y, tmp[p].y))",
			"            p = i;",
			"        else if(no_more(tmp[i].y, tmp[p].y) and less_than(tmp[i].x, tmp[p].x))",
			"            p = i;",
			"    }",
			"    std::vector<std::pair<Type, int> > vp(n);",
			"    for(int i = 0; i < n; ++i) {",
			"        if(i == p)",
			"            vp[i] = std::pair<Type, int>(-10.0, i);",
			"        else",
			"            vp[i] = std::pair<Type, int>(Vector(tmp[i] - tmp[p]).arg(), i);",
			"    }",
			"    std::sort(vp.begin(), vp.end());",
			"    for(int i = 0; i < n; ++i) pol[i] = tmp[vp[i].second];",
			"}",
			"",
			"Type area(const Point &A, const Point &B, const Point &C) { return std::abs(cross(B - A, C - A)) / 2.0; }  // 三角形の面積．",
			"Type area(const Polygon &pol) {                                                                            // O(N).",
			"    const int n = pol.size();",
			"    Type res = 0.0;",
			"    for(int i = 0; i < n; ++i) res += cross(pol[i], pol[(i + 1) % n]);",
			"    return res / 2.0;",
			"}",
			"",
			"// 多角形と点の包含関係．O(N).",
			"int contain(const Polygon &pol, const Point &P) {",
			"    const int n = pol.size();",
			"    bool jud = false;",
			"    for(int i = 0; i < n; ++i) {",
			"        Vector A = pol[i] - P, B = pol[(i + 1) % n] - P;",
			"        if(equal_to(cross(A, B), 0.0) and no_more(dot(A, B), 0.0)) return 1;  // on.",
			"        if(A.y > B.y) std::swap(A, B);",
			"        if(no_more(A.y, 0.0) and less_than(0.0, B.y) and more_than(cross(A, B), 0.0)) jud = !jud;",
			"    }",
			"    return (jud ? 2 : 0);  // in or out.",
			"}",
			"",
			"// 凸性判定．O(N).",
			"bool is_convex(const Polygon &pol) {",
			"    const int n = pol.size();",
			"    for(int i = 0; i < n; ++i) {",
			"        if(ccw(pol[i], pol[(i + 1) % n], pol[(i + 2) % n]) == -1) return false;",
			"    }",
			"    return true;",
			"}",
			"",
			"// アンドリューのアルゴリズム．凸包．O(N*logN).",
			"Polygon andrew_scan(Polygon &pol, bool eliminate_duplication = true) {",
			"    const int cmp = (eliminate_duplication ? geometry::EPS : -geometry::EPS);",
			"    const int n = pol.size();",
			"    Polygon res(2 * n);",
			"    int k = 0;",
			"    std::sort(pol.begin(), pol.end());",
			"    for(int i = 0; i < n; ++i) {",
			"        while(k >= 2 and cross(res[k - 1] - res[k - 2], pol[i] - res[k - 2]) < cmp) k--;",
			"        res[k++] = pol[i];",
			"    }",
			"    int t = k + 1;",
			"    for(int i = n - 2; i >= 0; --i) {",
			"        while(k >= t and cross(res[k - 1] - res[k - 2], pol[i] - res[k - 2]) < cmp) k--;",
			"        res[k++] = pol[i];",
			"    }",
			"    res.resize(k - 1);",
			"    return res;",
			"}",
			"",
			"// 凸多角形の切断．O(N).",
			"Polygon convex_cut(const Polygon &pol, const Line &l) {",
			"    assert(is_convex(pol));",
			"    const int n = pol.size();",
			"    Polygon res;",
			"    for(int i = 0; i < n; ++i) {",
			"        Point P = pol[i], Q = pol[(i + 1) % n];",
			"        if(ccw(l[0], l[1], P) != -1) {",
			"            if(res.size() == 0 or P != *res.rbegin()) res.push_back(P);",
			"        }",
			"        if(ccw(l[0], l[1], P) * ccw(l[0], l[1], Q) < 0) {",
			"            std::vector<Point> temp = cross_point(Line(P, Q), l);",
			"            if(temp.size() == 0) continue;",
			"            if(res.size() == 0 or temp[0] != *res.rbegin()) res.push_back(temp[0]);",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"}  // namespace geometry",
			"",
			"// using namespace geometry;"
		],
		"description": ""
	},
}